<h1>member</h1>
<p><br/><a href="https://s40523253.github.io/cd2020">40523253</a><br/><a href="https://40623117.github.io/cd2020">40623117</a><br/><a href="https://40623252.github.io/cd2020">40623252</a><br/><a href="https://s40723221.github.io/cd2020">40723221</a><span><span> </span>(group leader)</span><br/><a href="https://s40723222.github.io/cd2020">40723222</a> <br/><a href="https://s40723228.github.io/cd2020">40723228</a><br/><a href="https://s40723236.github.io/cd2020">40723236</a><br/><a href="https://s40723237.github.io/cd2020">40723237</a> (second leader)<br/><a href="https://s40723240.github.io/cd2020">40723240</a> <span>(second  leader)</span><br/><a href="https://s40723243.github.io/cd2020">40723243</a><br/><a href="https://s40723244.github.io/cd2020">40723244</a><br/><a href="https://s40723249.github.io/cd2020">40723249</a><br/><a href="https://40732331.github.io/cd2020">40732331</a></p><h1>week</h1>
<h2>week1-5</h2>
<h4><strong><span>week1</span></strong></h4>
<hr/>
<p>1.登入自己的github帳戶，並且創建名為cd2020的個人倉儲。</p>
<p>2.進入存放的資料夾例如;tmp</p>
<p>3.在小黑窗上打上git clone https://github.com/s40723221/cd2020。</p>
<p>4.git submodule add https://github.com/mdecourse/cmsimde.git。</p>
<p>5.完成後使用cd cd2020 -&gt;cd cmsimde進入cmsimde的資料夾內。</p>
<p>6.完成之後使用python wsgi.py進入靜態9443內編輯個人網站的資料。</p>
<p>7.使用git add .  -&gt; commit -m ＂標題＂ -&gt; git push將剛剛編輯好的東西上傳。</p>
<p>8.進入個人倉儲的setting中更改branch(分支)至master。</p>
<p><strong><span>影片教學:</span></strong></p>
<p><span><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/V7Njg-o9bm4" width="560"></iframe></span></p>
<hr/>
<h4><strong><span>week2</span></strong></h4>
<p><strong><span>將可攜系統下的python 3.7.3系統更新至python 3.8.2</span></strong></p>
<p><span>1.進入<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></span></p>
<p><span>2.往下滑到最底，下載<a href="https://www.python.org/ftp/python/3.8.2/python-3.8.2-amd64.exe">Windows x86-64 executable installer</a>(上下兩者分別為<a href="https://www.python.org/ftp/python/3.7.7/python-3.7.7-embed-amd64.zip">Windows x86-64 embeddable zip file</a>和<a href="https://www.python.org/ftp/python/3.7.7/python-3.7.7-amd64-webinstall.exe">Windows x86-64 web-based installer</a>這兩者是嵌入式64位元python的可執行壓縮檔案和64位元網際端的可執行檔案)在本次可熙的更新中不會使用到</span></p>
<p><span><img alt="" height="104" src="https://s40723221.github.io/cd2020/images/python%20%E5%9F%B7%E8%A1%8C%E6%AA%94.PNG" width="409"/></span></p>
<p><span>3.接著開始下載切記不要勾選pip選項，接著按下next</span></p>
<p><span>4.先將下載下來的python3.8.2放置桌面，並且將y槽下的data新增加一個py382的資料夾方便之後可以做測試是否3.8.2之python可以正常的運行</span></p>
<p><span>5.將剛剛下載之python3.8.2放置於剛剛創建的py382中切記不要將原先的py373刪除，若之後py382的執行產生錯誤才可以使用py373做返回原版本的動作</span></p>
<p><span>6.更改執行檔start_mdecourse.bat</span></p>
<p><strong><span>將底下py373處更改為自己下在python3.8.2所儲存的資料夾名稱</span></strong></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
subst %Disk%: "data"

%Disk%:

set HomePath=%Disk%:\home_mdecourse
set HomeDrive=%Disk%:\home_mdecourse
set Home=%Disk%:\home_mdecourse
set USERPROFILE=%Disk%:\home_mdecourse

REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"

set PYTHONPATH=%Disk%:\py373\DLLs;%Disk%:\py373\Lib;%Disk%:\py373\Lib\site-packages;
set PYTHONHOME=%Disk%:\py373

set GIT_HOME=%Disk%:\portablegit\bin\
set GIT_SSH=%Disk%:\putty\plink.exe

set path_python=%Disk%:\py373;%Disk%:\py373\Scripts;
set path_msys2=%Disk%:\msys64\mingw64\bin;
REM coreutils is for compiling fossil scm
set path_coreutils=%Disk%:\coreutils-5.3.0\bin;%Disk%:\depends22_x64;
set path_tcc=%Disk%:\tcc;
set path_cmake=%Disk%:\cmake-3.10.1-win64-x64\bin;
set path_nodejs=Disk%:\nodejs;%Disk%:\nodejs\appdata\roaming\npm;
set path_git=%Disk%:\portablegit\bin;
set path_xming=%Disk%:\Xming;
set path_latex=%%Disk%:\Pandoc;%Disk%:\TinyTeX\bin\win32;

path=%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;

start /MIN %Disk%:\wscite415\wscite\SciTE.exe
start /MIN %Disk%:\wscite415\wscite\SciTE.exe

start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe


Exit</pre>
<p><span></span>7.重新啟動剛剛更新的執行檔</p>
<p>8.執行<strong><span>python get-pip.py</span></strong></p>
<p>9..執行<strong><span>python -m pip install flask flask-cors markdown lxml bs4 pelican leo</span></strong></p>
<p><span><strong>影片教學:</strong></span></p>
<p><span><strong><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/ft4s-DvMk_M" width="560"></iframe></strong></span></p>
<hr/>
<p><span><strong>git pull request操作說明:</strong></span></p>
<p><span>1.以自己github之帳號fork老師的倉儲也就是<span>fork</span>:<a href="https://github.com/mdecourse/cd2020">https://github.com/mdecourse/cd2020</a></span></p>
<p><span>2.接下來到自己的倉儲中找到剛剛fork下來的老師倉儲並且複製網址</span></p>
<p><span>3.利用git clone 自己帳號下老師的網址</span></p>
<p><span>4.在執行git submodule add<span> </span><a href="https://github.com/mdecourse/cmsimde.git">https://github.com/mdecourse/cmsimde.git</a></span></p>
<p><span>5.進入到9443開始編輯自己帳號下老師的網站</span></p>
<p><span>6.編輯完成後執行git add commit push三個步驟</span></p>
<p><span>7.利用自己帳號下修改完成的老師倉儲建立新的pull request</span></p>
<p><span><img alt="" height="84" src="https://s40723221.github.io/cd2020/images/new%20pull%20request.PNG" width="207"/></span></p>
<p><span><img alt="" height="97" src="https://s40723221.github.io/cd2020/images/add%20commit%20pull%20request.PNG" width="1018"/></span></p>
<p><span>8.按下提交之後等待老師接受並且merge即可完成此次的pull request</span></p>
<p><span><strong><span color="#000000">w2直播進程:</span></strong></span></p>
<p><span><strong><span color="#000000">分工內容:</span></strong></span></p>
<p><span><span color="#000000">40523253:亂數分組程式<br/>40623117:亂數分組程式<br/>40623252:4輪車<br/>40723221 (group leader) :4輪車<br/>40723222:4輪車<br/>40723228:亂數分組程式<br/>40723236:4輪車<br/>40723237:可攜系統<br/>40723240:4輪車<br/>40723243:4輪車<br/>40723244:可攜系統<br/>40723249:可攜系統<br/>40732331:4輪車 </span></span></p>
<p><span><strong><span color="#000000">注意事項:</span></strong></span></p>
<p><span><span color="#000000">1.視課堂進度上傳影片<br/>2.不管會不會做每周都要push<br/>3.可以從gitter上面提問<br/>4.直播大家輪流主持，直播前半部分有教大家如何開直播了<br/>5.git pull request每個人都要會之後要更改東西比較方便<br/>6.不會做的可以去看我的網站我會盡可能提早更新，再不行就到gitter上面提問可以在這邊提問 gitter:https://gitter.im/mdecourse/cd2020<br/>7.2020年3月26日到期assignment 1的pdf繳交請在時間內上傳到自己倉儲的download上<br/>8.pdf上寫上進度，之後打分數依照pdf打分</span></span></p>
<p><span><strong><span color="#000000">直播進程影片:</span></strong></span></p>
<p><strong><span><span color="#000000"><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/HXS95dlMSv8" width="560"></iframe></span></span></strong></p>
<h4><strong><span>week3</span></strong></h4>
<p><span style="color: #ff0000;">40723221邱正宇的本周報告:</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/uDAZ07xBHMs" width="560"></iframe></p>
<p><span style="color: #ff0000;">40723249顏士勛的本周報告:</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/lGkbJC9OZ70" width="560"></iframe></p>
<h2>week6-10</h2>
<h4><strong>week6</strong></h4>
<p><span style="color: #ff0000;"><b>抽點報告:</b></span></p>
<p>40523253</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/o88lNqgScX4" width="560"></iframe></p>
<p><span><strong><span color="#000000">40732331已通知必需繳交報告但<span style="color: #ff0000;">未交</span></span></strong></span></p>
<p><span style="color: #ff0000;"><strong><span color="#000000">w6直播進程:</span></strong></span></p>
<p><span><strong><span color="#000000">分工內容:</span></strong></span></p>
<p><span>topic0:</span><br/>40723237<br/>40723221<br/>40723222<br/>40723228<br/>40723243<br/>40723244<br/>40723236<br/>40623117</p>
<p><span>topic1:</span><br/>40723221<br/>40723222<br/>40623252<br/>40523253<br/>40723249<br/>40732331<br/>40723240<br/>40723237</p>
<p><strong><span>直播進程影片:</span></strong></p>
<p><span><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/B6zwMXl1V3Y" width="560"></iframe></span></p>
<p><strong><span>4輪車參考影片:</span></strong></p>
<p><span><span>v-rep檔案:</span><a href="https://s40723221.github.io/cd2020/downloads/car%20easy%20setting%20for%20motor%20and%20model.ttt">car easy setting for motor and model</a></span></p>
<p><span>四輪車馬達驅動設定影片:</span></p>
<p><strong><span><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/kerPUu4UY1M" width="560"></iframe></span></strong></p>
<p>V-REP <yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">tutorial 影片:</yt-formatted-string></p>
<p><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/CXGJmwHt81g" width="560"></iframe></p>
<p><strong><span>將手機用做攝像頭</span></strong></p>
<p><span><a href="https://www.e2esoft.com/ivcam/"><span>ivcam:</span>https://www.e2esoft.com/ivcam/</a></span></p>
<p><img alt="" height="314" src="https://s40723221.github.io/cd2020/images/ivcam.PNG" width="353"/></p>
<p>obs:<a href="https://obsproject.com/">h<span>ttps://obsproject.com/</span></a></p>
<p><span><img alt="" height="244" src="https://s40723221.github.io/cd2020/images/obs.PNG" width="246"/></span></p>
<p><span>藉由obs之串流功能或者錄影功能即可使用錄影的方式進行線上教學及操作，若需要錄製操作者的臉或者是展示現場操作之步驟及方式亦可以使用ivcam對手機進行連結，並截油ivcam之功能達到與攝像頭相對應的功能。</span></p>
<p><span color="#000000">ivcam設定方式:</span></p>
<p><span color="#000000">1.安裝並且執行ivcam(手機電腦都需要安裝)</span></p>
<p><span color="#000000"><img alt="" height="218" src="https://s40723221.github.io/cd2020/images/ivcam-1.PNG" width="371"/></span></p>
<p><span color="#000000">2.連接後到obs去設定攝像頭</span></p>
<p><span color="#000000"><img alt="" height="411" src="https://s40723221.github.io/cd2020/images/obs%20cut.PNG" width="310"/></span></p>
<p><span color="#000000">3.結束後即可開始使用手機攝像頭</span></p>
<p><span color="#000000"><span>obs和youtube串流教學可以參考</span>:<a href="https://bearteach.com/bearman/3919">https://bearteach.com/bearman/3919</a></span></p>
<h4><strong>week7</strong></h4>
<p><span><strong><span color="#000000">四輪車馬達設定及鍵盤控制加速及轉彎</span></strong></span></p>
<p><span><a href="https://s40723221.github.io/cd2020/downloads/four%20wheel%20car%20setting%20to%20contorl%20turn%20right%20or%20left.ttt"><span>v-rep檔案:</span>four wheel car setting to contorl turn right or left</a></span></p>
<p><span><span color="#000000">1.將上面已經能夠直線運行的四輪車給導入v-rep，導入後左方工作列因該會呈現下方的樣態。</span></span></p>
<p><span><span color="#000000"><img alt="" height="172" src="https://s40723221.github.io/cd2020/images/tool1.png" width="278"/></span></span></p>
<p><span><span color="#000000">2.接下來我們回顧一下之前馬達設定的地方，我們必須要把電機開啟(</span></span>點擊子視窗下的<span>show dynamic properties dialog</span>，可以藉由勾選<span>motor properties</span>以啟動馬達，並可以藉由調整轉動速度和力矩達到所想要馬達轉動之效果，底下的<span>lock motor when target velocity is zero</span><span><span color="#000000">則可以使馬達速度為零時鎖定住馬達)。</span></span></p>
<p><span><span color="#000000"><img alt="" height="207" src="https://s40723221.github.io/cd2020/images/tool2.png" width="297"/></span></span></p>
<p><span><span color="#000000">3.物件的動力學設定也必須要設定好，如下方所示物體的碰撞和物體的動態都必須打開，才能使剛剛設定好的馬達進行對輪胎的帶動。</span></span></p>
<p><span><span color="#000000"><img alt="" height="260" src="https://s40723221.github.io/cd2020/images/tool3.png" width="382"/></span></span></p>
<p><span><span color="#000000">4.貼上撰寫好的鍵盤控制轉彎程式。</span></span></p>
<p><span><span color="#000000"><img alt="" height="418" src="https://s40723221.github.io/cd2020/images/tool4.png" width="893"/></span></span></p>
<p><span><strong><span color="#000000">操作影片:</span></strong></span></p>
<p><span><strong><span color="#000000"><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/oBbIP0TYf8E" width="560"></iframe></span></strong></span></p>
<p><strong><span>轉彎程式碼:</span></strong></p>
<div>
<div class="syntaxhighlighter html" id="highlighter_22596">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 1374px;">
<td class="gutter" style="height: 1374px;">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
<div class="line number5 index4 alt2">5</div>
<div class="line number6 index5 alt1">6</div>
<div class="line number7 index6 alt2">7</div>
<div class="line number8 index7 alt1">8</div>
<div class="line number9 index8 alt2">9</div>
<div class="line number10 index9 alt1">10</div>
<div class="line number11 index10 alt2">11</div>
<div class="line number12 index11 alt1">12</div>
<div class="line number13 index12 alt2">13</div>
<div class="line number14 index13 alt1">14</div>
<div class="line number15 index14 alt2">15</div>
<div class="line number16 index15 alt1">16</div>
<div class="line number17 index16 alt2">17</div>
<div class="line number18 index17 alt1">18</div>
<div class="line number19 index18 alt2">19</div>
<div class="line number20 index19 alt1">20</div>
<div class="line number21 index20 alt2">21</div>
<div class="line number22 index21 alt1">22</div>
<div class="line number23 index22 alt2">23</div>
<div class="line number24 index23 alt1">24</div>
<div class="line number25 index24 alt2">25</div>
<div class="line number26 index25 alt1">26</div>
<div class="line number27 index26 alt2">27</div>
<div class="line number28 index27 alt1">28</div>
<div class="line number29 index28 alt2">29</div>
<div class="line number30 index29 alt1">30</div>
<div class="line number31 index30 alt2">31</div>
<div class="line number32 index31 alt1">32</div>
<div class="line number33 index32 alt2">33</div>
<div class="line number34 index33 alt1">34</div>
<div class="line number35 index34 alt2">35</div>
<div class="line number36 index35 alt1">36</div>
<div class="line number37 index36 alt2">37</div>
<div class="line number38 index37 alt1">38</div>
<div class="line number39 index38 alt2">39</div>
<div class="line number40 index39 alt1">40</div>
<div class="line number41 index40 alt2">41</div>
<div class="line number42 index41 alt1">42</div>
<div class="line number43 index42 alt2">43</div>
<div class="line number44 index43 alt1">44</div>
<div class="line number45 index44 alt2">45</div>
<div class="line number46 index45 alt1">46</div>
<div class="line number47 index46 alt2">47</div>
<div class="line number48 index47 alt1">48</div>
<div class="line number49 index48 alt2">49</div>
<div class="line number50 index49 alt1">50</div>
<div class="line number51 index50 alt2">51</div>
<div class="line number52 index51 alt1">52</div>
<div class="line number53 index52 alt2">53</div>
<div class="line number54 index53 alt1">54</div>
<div class="line number55 index54 alt2">55</div>
<div class="line number56 index55 alt1">56</div>
<div class="line number57 index56 alt2">57</div>
<div class="line number58 index57 alt1">58</div>
<div class="line number59 index58 alt2">59</div>
<div class="line number60 index59 alt1">60</div>
<div class="line number61 index60 alt2">61</div>
<div class="line number62 index61 alt1">62</div>
<div class="line number63 index62 alt2">63</div>
<div class="line number64 index63 alt1">64</div>
<div class="line number65 index64 alt2">65</div>
<div class="line number66 index65 alt1">66</div>
<div class="line number67 index66 alt2">67</div>
<div class="line number68 index67 alt1">68</div>
<div class="line number69 index68 alt2">69</div>
<div class="line number70 index69 alt1">70</div>
<div class="line number71 index70 alt2">71</div>
<div class="line number72 index71 alt1">72</div>
<div class="line number73 index72 alt2">73</div>
<div class="line number74 index73 alt1">74</div>
<div class="line number75 index74 alt2">75</div>
</td>
<td class="code" style="height: 1374px;">
<div class="container">
<div class="line number1 index0 alt2"><code class="html plain">function sysCall_init() </code></div>
<div class="line number2 index1 alt1"><code class="html spaces">    </code><code class="html plain">left_front_handle= sim.getObjectHandle('left_m')</code></div>
<div class="line number3 index2 alt2"><code class="html spaces">    </code><code class="html plain">left_back_handle= sim.getObjectHandle('left_m')</code></div>
<div class="line number4 index3 alt1"><code class="html spaces">    </code><code class="html plain">right_back_handle= sim.getObjectHandle('right_m')</code></div>
<div class="line number5 index4 alt2"><code class="html spaces">    </code><code class="html plain">right_front_handle= sim.getObjectHandle('right_m')</code></div>
<div class="line number6 index5 alt1"><code class="html spaces">    </code><code class="html plain">MaxVel=2</code></div>
<div class="line number7 index6 alt2"><code class="html spaces">    </code><code class="html plain">leftvelocity=0</code></div>
<div class="line number8 index7 alt1"><code class="html spaces">    </code><code class="html plain">rightvelocity=0</code></div>
<div class="line number9 index8 alt2"><code class="html spaces">    </code><code class="html plain">dVel=0.5;</code></div>
<div class="line number10 index9 alt1"><code class="html spaces">    </code><code class="html plain">--sim.setJointTargetVelocity(left_front_handle,leftvelocity)</code></div>
<div class="line number11 index10 alt2"><code class="html spaces">    </code><code class="html plain">sim.setJointTargetVelocity(left_back_handle,leftvelocity)</code></div>
<div class="line number12 index11 alt1"><code class="html spaces">    </code><code class="html plain">sim.setJointTargetVelocity(right_back_handle,rightvelocity)</code></div>
<div class="line number13 index12 alt2"><code class="html spaces">    </code><code class="html plain">--sim.setJointTargetVelocity(right_front_handle,rightvelocity)</code></div>
<div class="line number14 index13 alt1"><code class="html plain">end</code></div>
<div class="line number15 index14 alt2"> </div>
<div class="line number16 index15 alt1"><code class="html plain">function sysCall_actuation() </code></div>
<div class="line number17 index16 alt2"><code class="html spaces">    </code><code class="html plain">message,auxiliaryData=sim.getSimulatorMessage()</code></div>
<div class="line number18 index17 alt1"><code class="html spaces">    </code><code class="html plain">while message~=-1 do</code></div>
<div class="line number19 index18 alt2"><code class="html spaces">        </code><code class="html plain">if (message==sim.message_keypress) then</code></div>
<div class="line number20 index19 alt1"><code class="html spaces">            </code><code class="html plain">if (auxiliaryData[1]==32) then</code></div>
<div class="line number21 index20 alt2"><code class="html spaces">                </code><code class="html plain">-- right key</code></div>
<div class="line number22 index21 alt1"><code class="html spaces">                </code><code class="html plain">leftvelocity=0</code></div>
<div class="line number23 index22 alt2"><code class="html spaces">                </code><code class="html plain">rightvelocity=0</code></div>
<div class="line number24 index23 alt1"><code class="html spaces">                </code><code class="html plain">sim.setJointForce(left_front_handle, 0)</code></div>
<div class="line number25 index24 alt2"><code class="html spaces">                </code><code class="html plain">sim.setJointForce(left_back_handle, 0)</code></div>
<div class="line number26 index25 alt1"><code class="html spaces">                </code><code class="html plain">sim.setJointForce(right_back_handle, 0)</code></div>
<div class="line number27 index26 alt2"><code class="html spaces">                </code><code class="html plain">sim.setJointForce(right_front_handle, 0)</code></div>
<div class="line number28 index27 alt1"><code class="html spaces">                </code><code class="html plain">break</code></div>
<div class="line number29 index28 alt2"><code class="html spaces">            </code><code class="html plain">else</code></div>
<div class="line number30 index29 alt1"><code class="html spaces">                </code><code class="html plain">--sim.setJointForce(left_front_handle, 10000)</code></div>
<div class="line number31 index30 alt2"><code class="html spaces">                </code><code class="html plain">sim.setJointForce(left_back_handle, 10000)</code></div>
<div class="line number32 index31 alt1"><code class="html spaces">                </code><code class="html plain">sim.setJointForce(right_back_handle, 10000)</code></div>
<div class="line number33 index32 alt2"><code class="html spaces">                </code><code class="html plain">--sim.setJointForce(right_front_handle, 10000)</code></div>
<div class="line number34 index33 alt1"><code class="html spaces">            </code><code class="html plain">end</code></div>
<div class="line number35 index34 alt2"><code class="html spaces">            </code><code class="html plain">if (auxiliaryData[1]==2007) then</code></div>
<div class="line number36 index35 alt1"><code class="html spaces">                </code><code class="html plain">-- up key</code></div>
<div class="line number37 index36 alt2"><code class="html spaces">                </code><code class="html plain">leftvelocity=(leftvelocity+rightvelocity)/2</code></div>
<div class="line number38 index37 alt1"><code class="html spaces">                </code><code class="html plain">rightvelocity=leftvelocity</code></div>
<div class="line number39 index38 alt2"><code class="html spaces">                </code><code class="html plain">leftvelocity=leftvelocity+dVel</code></div>
<div class="line number40 index39 alt1"><code class="html spaces">                </code><code class="html plain">rightvelocity=rightvelocity+dVel</code></div>
<div class="line number41 index40 alt2"><code class="html spaces">            </code><code class="html plain">end</code></div>
<div class="line number42 index41 alt1"><code class="html spaces">            </code><code class="html plain">if (auxiliaryData[1]==2008) then</code></div>
<div class="line number43 index42 alt2"><code class="html spaces">                </code><code class="html plain">-- down key</code></div>
<div class="line number44 index43 alt1"><code class="html spaces">                </code><code class="html plain">leftvelocity=(leftvelocity+rightvelocity)/2</code></div>
<div class="line number45 index44 alt2"><code class="html spaces">                </code><code class="html plain">rightvelocity=leftvelocity</code></div>
<div class="line number46 index45 alt1"><code class="html spaces">                </code><code class="html plain">leftvelocity=leftvelocity-dVel</code></div>
<div class="line number47 index46 alt2"><code class="html spaces">                </code><code class="html plain">rightvelocity=rightvelocity-dVel</code></div>
<div class="line number48 index47 alt1"><code class="html spaces">            </code><code class="html plain">end</code></div>
<div class="line number49 index48 alt2"><code class="html spaces">            </code><code class="html plain">if (auxiliaryData[1]==2009) then</code></div>
<div class="line number50 index49 alt1"><code class="html spaces">                </code><code class="html plain">-- left key</code></div>
<div class="line number51 index50 alt2"><code class="html spaces">                </code><code class="html plain">leftvelocity=leftvelocity-dVel</code></div>
<div class="line number52 index51 alt1"><code class="html spaces">                </code><code class="html plain">rightvelocity=rightvelocity+dVel</code></div>
<div class="line number53 index52 alt2"><code class="html spaces">            </code><code class="html plain">end</code></div>
<div class="line number54 index53 alt1"><code class="html spaces">            </code><code class="html plain">if (auxiliaryData[1]==2010) then</code></div>
<div class="line number55 index54 alt2"><code class="html spaces">                </code><code class="html plain">-- right key</code></div>
<div class="line number56 index55 alt1"><code class="html spaces">                </code><code class="html plain">leftvelocity=leftvelocity+dVel</code></div>
<div class="line number57 index56 alt2"><code class="html spaces">                </code><code class="html plain">rightvelocity=rightvelocity-dVel</code></div>
<div class="line number58 index57 alt1"><code class="html spaces">            </code><code class="html plain">end</code></div>
<div class="line number59 index58 alt2"><code class="html spaces">        </code><code class="html plain">end</code></div>
<div class="line number60 index59 alt1"><code class="html spaces">        </code><code class="html plain">message,auxiliaryData=sim.getSimulatorMessage()</code></div>
<div class="line number61 index60 alt2"><code class="html spaces">    </code><code class="html plain">end</code></div>
<div class="line number62 index61 alt1"><code class="html spaces">    </code> </div>
<div class="line number63 index62 alt2"><code class="html spaces">    </code><code class="html plain">if leftvelocity&gt;MaxVel then</code></div>
<div class="line number64 index63 alt1"><code class="html spaces">        </code><code class="html plain">leftvelocity=MaxVel</code></div>
<div class="line number65 index64 alt2"><code class="html spaces">    </code><code class="html plain">end</code></div>
<div class="line number66 index65 alt1"><code class="html spaces">    </code><code class="html plain">if leftvelocity&lt;-maxvel then="" leftvelocity="-MaxVel" end="" if="" rightvelocity=""&gt;MaxVel then</code></div>
<div class="line number67 index66 alt2"><code class="html spaces">                </code><code class="html plain">rightvelocity=MaxVel</code></div>
<div class="line number68 index67 alt1"><code class="html spaces">    </code><code class="html plain">end</code></div>
<div class="line number69 index68 alt2"> </div>
<div class="line number70 index69 alt1"><code class="html spaces">    </code><code class="html plain">--sim.setJointTargetVelocity(left_front_handle,leftvelocity)</code></div>
<div class="line number71 index70 alt2"><code class="html spaces">    </code><code class="html plain">sim.setJointTargetVelocity(left_back_handle,leftvelocity)</code></div>
<div class="line number72 index71 alt1"><code class="html spaces">    </code><code class="html plain">sim.setJointTargetVelocity(right_back_handle,rightvelocity)</code></div>
<div class="line number73 index72 alt2"><code class="html spaces">    </code><code class="html plain">--sim.setJointTargetVelocity(right_front_handle,rightvelocity)</code></div>
<div class="line number74 index73 alt1"> </div>
<div class="line number75 index74 alt2"><code class="html plain">end</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p><span>結論:</span></p>
<p><span>在這邊我們已經通過了前面的馬達設定、動力學設定、v-rep內部簡易物件組立完成了一輛能夠直行的四輪車，在這邊我們更透過指令碼的方式增加了四輪車可以通過鍵盤達成左轉右轉及向前加速和減速的功能，雖然依舊會有輪胎打滑的問題存在，但是通過之後藉由機構之設計及模擬因該能夠解決此一問題。</span></p><h2>week11-15</h2>
<h2>week16-18</h2>
<h1>CoppeliaSIM</h1>
<h2>External controller</h2>
<p><span style="color: #0000ff;">本資料由40723240提供</span></p>
<p><strong><span style="color: #ff0000;">External controller tutorial </span></strong><br/><strong><span style="color: #ff0000;"> 外部控制器教程 </span></strong></p>
<p><span style="color: #ff0000;">There are several ways one can control a robot or simulation in CoppeliaSim:</span> <br/>在 CoppeliaSim 中，有幾種方法可以控制機器人或使其模擬更加仿真： <br/> <br/><span style="color: #ff0000;">The most convenient way is to write a child script that will handle the behaviour of a given robot or model. It is the most convenient way, because child scripts are directly attached to scene objects, they will be duplicated together with their associated scene objects, they do not need any compilation with an external tool, they can run in threaded or non-threaded mode, they can be extended via custom Lua function or via a Lua extension library. Another major advantage in using child scripts: there is no communication lag as with the last 3 methods mentioned in this section (i.e. the regular API is used), and child scripts are part of the application main thread (inherent synchronous operation). There are several drawback to writing scripts however: you don't have the choice of the programming language, you can't have the fastest code, and you can't directly access external function libraries, except the Lua extension libraries.</span></p>
<p><br/>最方便的方法是編寫一段指令來處理給定機器人或模型的動作。這<br/>是最方便的方法，因為指令直接附加到物件上，它們將與相關的物<br/>件一起復制，它們不需要使用外部工具進行任何編譯，它們可以在<br/>線性或非線性模式下運行，它們可以通過自定義 Lua 函數或 Lua 擴<br/>展庫進行擴展。使用指令的另一個主要優點是：與本節中提到的後<br/>3 種方法（即使用常規 API）一樣，沒有通信延遲，並且指令是應用<br/>程序主線程的一部分（固有的同步操作）。但是，編寫指令有幾個缺<br/>點：您無法選擇編程語言，不能擁有最快的代碼，並且除了 Lua 擴<br/>展庫之外，您無法直接訪問外部函數庫。 <br/> <br/><span style="color: #ff0000;">Another way one can control a robot or a simulation is by writing a plugin. The plugin mechanism allows for callback mechanisms, custom Lua function registration, and of course access to external function libraries. A plugin is often used in conjunction with child scripts (e.g. the plugin registers custom Lua functions, that, when called from a child script, will call back a specific plugin function). A major advantage in using plugins is also that there is no communication lag as with the last 3 methods mentioned in this section (i.e. the regular API is used), and that a plugin is part of the application main thread (inherent synchronous operation). The drawbacks with plugins are: they are more complicated to program, and they need to be compiled with an external too. Refer also to the plugin tutorial.</span></p>
<p><br/>可以控制機器人或模擬的另一種方法是編寫插件。插件機制允許使<br/>用回調機制，自定義 Lua 函數註冊，當然還可以訪問外部函數庫。<br/>插件通常與指令結合使用（例如，插件註冊自定義的 Lua 函數，當<br/>從指令中調用時，該 Lua 函數將回調特定的插件函數）。使用插件的<br/>主要優勢還在於，與本節中提到的後 3 種方法（即使用常規 API）一<br/>樣，沒有通信延遲，並且插件是應用程序主線程的一部分（固有的<br/>同步操作）。插件的缺點是：它們的編程更加複雜，並且也需要使用<br/>外部編譯。另請參閱插件教程。 <br/> <br/><span style="color: #ff0000;">A third and forth way one can control a robot or a simulation is by </span><br/><span style="color: #ff0000;">writing an external client application that relies on the remote API. This is a very convenient and easy way, if you need to run the control code from an external application, from a robot or from another computer. This also allows you to control a simulation or a model (e.g. a virtual robot) with the exact same code as the one that runs the real robot. The remote API comes in two versions: the B0-based remote API, and the legacy remote API.</span></p>
<p><br/>控制機器人或模擬的第三種方法是編寫依賴於遠程 API 的外部客戶<br/>端應用程序。如果您需要從外部應用程序，機器人或另一台電腦運<br/>行控制代碼，這是一種非常便捷的方法。這也使您可以使用與運行<br/>真實機器人完全相同的代碼來控制仿真機器人或模型（例如虛擬機<br/>器人）。遠程 API 有兩個版本：基於 B0 的遠程 API 和舊版遠程 API。 <br/> <br/><span style="color: #ff0000;">A fifth way to control a robot or a simulation is via a ROS node. In a similar way as the remote API, ROS is a convenient way to have several distributed processes communicate with each other. While the remote API is very lightweight and fast, it allows only communication with CoppeliaSim. ROS on the other hand allows connecting virtually any number of processes with each other, and a large amount of compatible libraries are available. It is however heavier and more complicated than the remote API. Refer to the ROS interfaces for details.</span></p>
<p><br/>控制機器人或仿真的第五種方法是通過 ROS 節點。 ROS 與遠程 API<br/>相似，是使多個分佈式進程相互通信的便捷方法。儘管遠程 API 非<br/>常輕巧且快速，但它僅允許與 CoppeliaSim 通信。另一方面，ROS 允<br/>許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。但<br/>是，它比遠程 API 多並且更複雜。有關詳細信息，請參閱 ROS 接<br/>口。</p>
<p><span style="color: #ff0000;">A sixth way to control a robot or a simulation is via a BlueZero (BØ) node. In a similar way as ROS, BlueZero is a convenient way to have several distributed processes communicate with each other, and is a lightweight and cross-platform solution. Refer to the BlueZero interface for details.</span></p>
<p><br/>控制機器人或模擬的第六種方法是通過 BlueZero（BØ）節點。與<br/>ROS 類似，BlueZero 是使多個分佈式進程相互通信的一種便捷方<br/>法，並且是一種輕量的跨平台解決方案。有關詳細信息，請參考<br/>BlueZero 界面。 <br/> <br/><span style="color: #ff0000;">A seventh way to control a robot or a simulation is by writing an external application that communicates via various means (e.g. pipes, sockets, serial port, etc.) with a CoppeliaSim plugin or CoppeliaSim script. Two major advantages are the choice of programming language, which can be just any language, and the flexibility. Here also, the control code can run on a robot, or a different computer. This way of controlling a simulation or a model is however more tedious that the methods with the remote API.</span></p>
<p><br/>控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用<br/>程序通過各種方式（例如管道，套接字，串行端口等）與<br/>CoppeliaSim 插件或 CoppeliaSim 腳本進行通信。選擇編程語言（可<br/>以是任何一種語言）和靈活性是兩個主要優點。同樣，控制代碼也<br/>可以在機器人或其他電腦上運行。但是，與使用遠程 API 的方法相<br/>比，這種控制仿真或模型的方法更加乏味。</p>
<p><br/><span style="color: #ff0000;">There are 8 scene files related to this tutorial: </span><br/><span style="color: #ff0000;">scenes/controlTypeExamples/controlledViaScript : one robot is controlled via a non-threaded child script, the other is controlled via a threaded child script. scenes/controlTypeExamples/controlledViaPlugin : the robot is controlled via a plugin. scenes/controlTypeExamples/controlledViaB0RemoteApi : the robot is controlled via the B0-based remote API. scenes/controlTypeExamples/controlledViaLegacyRemoteApi : the robot is controlled via the legacy remote API. scenes/controlTypeExamples/controlledViaB0 : the robot is controlled via the BlueZero interface. scenes/controlTypeExamples/con trolledViaRos : the robot is controlled via the ROS interface. scenes/controlTypeExamples/controlledViaRos2 : the robot is controlled via the ROS2 interface. scenes/controlTypeExamples/controlledViaTcp : the robot is controlled via LuaSocket and TCP.</span></p>
<p>有 8 個與本教程相關的場景文件： scenes / controlTypeExamples /受<br/>控 ViaScript：一個機器人是通過非線程子腳本控制的，另一個是通過<br/>線程子腳本控制的。 scenes / controlTypeExamples /受控ViaPlugin：機器人是通過插件控制的。 scenes / controlTypeExamples / controlViaB0RemoteApi：通過基於 B0 的遠程API 來控制機器人。 scenes / controlTypeExamples /受控<br/>ViaLegacyRemoteApi：通過舊版遠程 API 控制機器人。 scenes / <br/>controlTypeExamples / controlViaB0：通過 BlueZero 界面控制機器<br/>人。 scenes / controlTypeExamples /受控 ViaRos：通過 ROS 接口控<br/>制機器人。 scenes / controlTypeExamples / controlViaRos2：通過<br/>ROS2 接口控制機器人。 scenes / controlTypeExamples /受控<br/>ViaTcp：通過 LuaSocket 和 TCP 控制機器人。</p>
<p><img alt="" height="549" src="/images/g.PNG" width="714"/></p>
<p><span style="color: #ff0000;">In all 8 cases, child scripts are used, mainly to make the link with the outside world (e.g. launch the correct client application, and pass the correct object handles to it). There are two other ways one can control a robot, a simulation, or the simulator itself: by using customization scripts, or add-ons. They are however not recommended for control and should be rather used to handle functionality while simulation is not running. </span><br/><span style="color: #ff0000;">As an example, the child script linked to the robot in scene controlledViaB0RemoteApi.ttt has following main task: </span></p>
<p><br/>在所有 8 種情況下，都使用子腳本，主要是為了與外界建立鏈接<br/>（例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給<br/>它）。有兩種其他方法可以控制機器人，模擬或模擬器本身：使用自<br/>定義腳本或附加組件。但是，不建議將它們用於控制，而應在不運<br/>行模擬時將其用於處理功能。例如，鏈接到場景控制的<br/>ViaB0RemoteApi.ttt 中的機器人的子腳本具有以下主要任務：</p>
<p><br/> <span style="color: #ff0000;">Launch the controller application (bubbleRobClient_b0RemoteApi) with some object handles as arguments. The server functionality of the B0-based remote API is provided by object b0RemoteApiServer . </span><br/><span style="color: #ff0000;">As another example, the child script linked to the robot in scene controlledViaRos.ttt has following main tasks: </span><br/><span style="color: #ff0000;">Check if the ROS Interface for CoppeliaSim was loaded Launch the controller application (rosBubbleRob) with some topic names or object handles as arguments</span> <br/> <br/>使用某些對象作為參數啟動控制器應用程序<br/>（bubbleRobClient_b0RemoteApi）。基於對象 B0 的遠程 API 的服<br/>務器功能由對象 b0RemoteApiServer 提供。作為另一個示例，鏈接<br/>到場景控制的 ViaRos.ttt 中的機器人的子腳本具有以下主要任務：<br/>檢查是否已加載 CoppeliaSim 的 ROS 接口使用某些主題名稱或對象<br/>作為參數啟動控制器應用程序（rosBubbleRob） <br/> <br/><span style="color: #ff0000;">Yet, as another example, the child script linked to the robot in scene controlledViaTcp.ttt has following main tasks: </span><br/><span style="color: #ff0000;"> Search for a free socket connection port </span><br/><span style="color: #ff0000;"> Launch the controller application (bubbleRobServer) with the chosen connection port as argument Locally connect to the controller application At each simulation pass, send the sensor values to the controller, and read the desired motor values from the controller At each simulation pass, apply the desired motor values to the robot's joints </span><br/><span style="color: #ff0000;">Run the simulations, and copy-and-paste the robot: you will see that the duplicated robots will directly be operational, since their attached child scripts are in charge of launching new instances of their respective external applications, or calling the appropriate plugin functions. </span></p>
<p><br/>然而，作為另一個示例，鏈接到場景控制的 ViaTcp.ttt 中的機器人的<br/>子腳本具有以下主要任務：搜索空閒的套接字連接端口使用所選的<br/>連接端口作為參數啟動控制器應用程序（bubbleRobServer）本地連<br/>接到控制器應用程序在每次仿真過程中，將傳感器值發送到控制<br/>器，並從控制器讀取所需的電機值在每次模擬過程中，將所需的電<br/>機值應用於機器人的關節運行模擬，然後復制並粘貼機器人：您將<br/>看到重複的機器人將直接運行，因為它們附加的子腳本負責啟動各<br/>自外部應用程序的新實例或調用適當的插件功能。</p>
<h2>BubbleRob</h2>
<p><span style="color: #0000ff;">由40723222提供</span></p>
<p><span style="color: #ff0000;">BubbleRob tutorial </span><br/> <br/><span style="color: #ff0000;">This tutorial will try to introduce quite many CoppeliaSim functionalities while designing the simple mobile robot BubbleRob. The CoppeliaSim scene file related to this tutorial is located in CoppeliaSim's installation folder's tutorials/BubbleRob folder. Following figure illustrates the simulation scene that we will design:</span><span style="color: #0000ff;"> <br/> <br/><span style="color: #000000;">本教程將設計簡單的移動機器人 BubbleRob 並嘗試介紹很多 CoppeliaSim 功能。 與本教程相關的 CoppeliaSim 場景文件位於 CoppeliaSim 的安裝文件夾的 tutorials / BubbleRob 文件夾中。下圖說明了我們將設計的仿真場景：</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><img alt="" height="464" src="/images/1.png" width="738"/></span></span></p>
<p><span style="color: #ff0000;">Since this tutorial will fly over many different aspects, make sure to also have a look at the other tutorials, mainly the tutorial about building a simulation model. First of all, freshly start CoppeliaSim. The simulator displays a default scene. We will start with the body of BubbleRob.</span></p>
<p>由於本教程將跨越許多不同的方面，因此請確保也看看其他教程，主要是有關構建仿真模型的教程。首先，重新啟動CoppeliaSim。模擬器顯示默認場景。我們將從BubbleRob的主體開始。</p>
<p><span style="color: #ff0000;">We add a primitive sphere of diameter 0.2 to the scene with [Menu bar --&gt; Add --&gt; Primitive shape --&gt; Sphere]. We adjust the X-size item to 0.2, then click OK. The created sphere will appear in the visibility layer 1 by default, and be dynamic and respondable (since we kept the item Create dynamic and respondable shape enabled). This means that BubbleRob's body will be falling and able to react to collisions with other respondable shapes (i.e. simulated by the physics engine). We can see this is the shape dynamics properties: items Body is respondable and Body is dynamic are enabled. We start the simulation (via the toolbar button, or by pressing &lt;control-space&gt; in the scene window), and copy-and-paste the created sphere (with [Menu bar --&gt; Edit --&gt; Copy selected objects] then [Menu bar --&gt; Edit -&gt; Paste buffer], or with &lt;control-c&gt; then &lt;control-v&gt;): the two spheres will react to collision and roll away. We stop the simulation: the duplicated sphere will automatically be removed. This default behaviour can be modified in the simulation dialog.</span></p>
<p>我們使用[Menu bar --&gt; Add --&gt; Primitive shape --&gt; Sphere]將直徑為0.2的基本球體添加到場景中。我們將X尺寸項目調整為0.2，然後單擊“確定”。默認情況下，創建的球體將顯示在可見性層1中，並且因該是動態且可響應的（因為我們已啟用“Create dynamic and responsive shapes”）。這意味著BubbleRob的身體會掉落並且能夠對與其他可響應形狀的碰撞做出反應（即由物理引擎模擬）。我們可以看到這是“Shape dynamics”屬性：啟用了“The body can respond”和“Body is dynamic”項目。我們開始模擬（通過工具欄按鈕，或在場景窗口中按&lt;control-space&gt;），然後復制並貼上創建的球體（使用[Menu bar --&gt; Edit --&gt; Copy selected objects]，然後[Menu bar --&gt; Edit -&gt; Paste buffer]，或者先按&lt;control-c&gt;，再按&lt;control-v&gt;）：這兩個球將對碰撞做出反應並滾動。我們停止模擬：重複的球體將自動刪除。可以在模擬對話框中修改此默認行為。</p>
<p><span style="color: #ff0000;">We also want the BubbleRob's body to by usable by the other calculation modules (e.g. the minimum distance calculation module). For that reason, we enable Collidable, Measurable, Renderable and Detectable in the object common properties for that shape, if not already enabled. If we wanted, we could now also change the visual appearance of our sphere in the shape properties.</span></p>
<p>我們還希望BubbleRob的主體可以被其他計算模塊（例如最小距離計算模塊）使用。因此，如果尚未啟用，則在該形狀的對象公共屬性中啟用“Collidable”，“Measurable”，“Renderable”和“Detectable”。如果需要，我們現在還可以在形狀屬性中更改球體的視覺外觀。</p>
<p><span style="color: #ff0000;">Now we open the position dialog on the translation tab, select the sphere representing BubbleRob's body, and enter 0.02 for Along Z. We make sure that the Relative to-item is set to World. Then we click Translate selection. This translates all selected objects by 2 cm along the absolute Z-axis, and effectively lifted our sphere a little bit. In the scene hierarchy, we double-click the sphere's name, so that we can edit its name. We enter bubbleRob and press enter.</span></p>
<p>現在，我們在“平移translation”選項上打開“位置position”對話框，選擇表示BubbleRob身體的球體，並為“沿Z”輸入0.02。確保將“相對於”項設置為“世界World”。然後我們點擊Translate選擇。這會將所有選定對象沿絕對Z軸平移2 cm，並有效地將我們的球體抬高了一點。在場景層次結構中，我們雙擊球體的名稱，以便我們可以編輯其名稱。我們輸入bubbleRob，然後按Enter。</p>
<p><span style="color: #ff0000;">Next we will add a proximity sensor so that BubbleRob knows when it is approaching obstacles: we select [Menu bar --&gt; Add --&gt; Proximity sensor --&gt; Cone type]. In the orientation dialog on the orientation tab, we enter 90 for Around Y and for Around Z, then click Rotate selection. In the position dialog, on the position tab, we enter 0.1 for X-coord. and 0.12 for Z-coord. The proximity sensor is now correctly positioned relative to BubbleRob's body. We double-click the proximity sensor's icon in the scene hierarchy to open its properties dialog. We click Show volume parameter to open the proximity sensor volume dialog. We adjust items Offset to 0.005, Angle to 30 and Range to 0.15. Then, in the proximity sensor properties, we click Show detection parameters. This opens the proximity sensor detection parameter dialog. We uncheck item Don't allow detections if distance smaller than then close that dialog again. In the scene hierarchy, we double-click the proximity sensor's name, so that we can edit its name. We enter bubbleRob_sensingNose and press enter.</span></p>
<p>接下來，我們將添加一個距離傳感器，以便BubbleRob知道它何時接近障礙物：我們選擇[Menu bar --&gt; Add --&gt; Proximity sensor --&gt; Cone type]。在“方向orientation”選項上的“方向orientation”對話框中，我們為“周圍的Y”和“周圍的Z”輸入90，然後單擊“旋轉選擇Rotate selection”。在位置對話框的“位置position”選項上，為X坐標輸入0.1。 Z坐標為0.12。現在，接近傳感器已相對於BubbleRob的身體正確定位。我們在場景層次中雙擊接近傳感器的圖標以打開其屬性對話框。我們單擊顯示體積參數以打開接近傳感器體積對話框。我們將偏移量調整為0.005，角度調整為30，範圍調整為0.15。然後，在距離傳感器屬性中，單擊“顯示檢測參數Show detection parameters”。這將打開距離傳感器去檢測參數對話框。如果距離小於則取消選中“不允許檢測Don't allow detections”項，然後再次關閉該對話框。在場景層次結構中，我們雙擊距離傳感器的名稱，以便我們可以編輯其名稱。我們輸入bubbleRob_sensingNose並enter。</p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><span style="color: #ff0000;">We select bubbleRob_sensingNose, then control-select bubbleRob, then click [Menu bar --&gt; Edit --&gt; Make last selected object parent]. This attaches the sensor to the body of the robot. We could also have dragged bubbleRob_sensingNose onto bubbleRob in the scene hierarchy. This is what we now have:</span><br/> <br/> 我們選擇bubbleRob_sensingNose，然後按住Control鍵選擇bubbleRob，然後單擊[Menu bar --&gt; Edit --&gt;將上一個選定的對象設為parent]。這會將傳感器連接到機器人的身體。我們還可以將bubbleRob_sensingNose拖動到場景層次中的bubbleRob上。這就是我們現在擁有的：</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><img alt="" height="523" src="/images/2.png" width="692"/></span></span></p>
<p>[Proximity sensor attached to bubbleRob's body]</p>
<p><span style="color: #ff0000;">Next we will take care of BubbleRob's wheels. We create a new scene with [Menu bar --&gt; File --&gt; New scene]. It is often very convenient to work across several scenes, in order to visualize and work only on specific elements. We add a pure primitive cylinder with dimensions (0.08,0.08,0.02). As for the body of BubbleRob, we enable Collidable, Measurable, Renderable and Detectable in the object common properties for that cylinder, if not already enabled. Then we set the cylinder's absolute position to (0.05,0.1,0.04) and its absolute orientation to (-90,0,0). We change the name to bubbleRob_leftWheel. We copy and paste the wheel, and set the absolute Y coordinate of the copy to -0.1. We rename the copy to bubbleRob_rightWheel. We select the two wheels, copy them, then switch back to scene 1, then paste the wheels.</span></p>
<p>接下來，我們將設定BubbleRob的車輪。我們使用[Menu bar --&gt; File --&gt; New scene]創建一個新場景。跨多個場景工作通常非常方便，以便可視化並僅對特定元素進行工作。我們添加一個尺寸為（0.08,0.08,0.02）的圓柱體。對於BubbleRob的主體，如果尚未啟用，則在該圓柱的對象通用屬性中啟用Collidable，Measurable，Renderable和Detectable。然後，將圓柱的絕對位置設置為（0.05,0.1,0.04），並將其絕對方向設置為（-90,0,0）。我們將名稱更改為bubbleRob_leftWheel。我們複製並粘貼滾輪，然後將復制的絕對Y坐標設置為-0.1。我們將物件名稱重新命名為bubbleRob_rightWheel。我們選擇兩個輪子，複製它們，然後切換回場景1，然後貼上輪子。</p>
<p><span style="color: #ff0000;">We now need to add joints (or motors) for the wheels. We click [Menu bar --&gt; Add --&gt; Joint --&gt; Revolute] to add a revolute joint to the scene. Most of the time, when adding a new object to the scene, the object will appear at the origin of the world. We Keep the joint selected, then control-select bubbleRob_leftWheel. In the position dialog, on the position tab, we click the Apply to selection button: this positioned the joint at the center of the left wheel. Then, in the orientation dialog, on the orientation tab, we do the same: this oriented the joint in the same way as the left wheel. We rename the joint to bubbleRob_leftMotor. We now double-click the joint's icon in the scene hierarchy to open the joint properties dialog. Then we click Show dynamic parameters to open the joint dynamics properties dialog. We enable the motor, and check item Lock motor when target velocity is zero. We now repeat the same procedure for the right motor and rename it to bubbleRob_rightMotor. Now we attach the left wheel to the left motor, the right wheel to the right motor, then attach the two motors to bubbleRob. This is what we have:</span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;">現在，我們需要為車輪添加動力（或電動機）。我們單擊[Menu bar --&gt; Add --&gt; Joint --&gt; Revolute]將旋轉關節添加到場景。在大多數情況下，將新對象添加到場景時，該對象將出現在世界的起始處。我們保持動力件處於選中狀態，然後控制選擇bubbleRob_leftWheel。在位置對話框的“位置position”選項上，我們單擊“Apply”選擇按鈕：這將動力定位在左輪的中心。然後，在“方向”對話框中的“方向”選項卡上，執行相同的操作：這將關節與左輪定向的方向相同。我們將關節重命名為bubbleRob_leftMotor。現在，我們在場景層次中雙擊關節的圖標以打開關節屬性對話框。然後，單擊“顯示動態參數”以打開關節動力學屬性對話框。我們啟用電動機，然後選中目標速度為零時鎖定電動機。現在，我們對右馬達重複相同的過程，並將其重命名為bubbleRob_rightMotor。現在，我們將左輪連接到左馬達，將右輪連接到右馬達，然後將兩個馬達連接到bubbleRob。這就是我們所擁有的：</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><img alt="" height="536" src="/images/3.png" width="724"/></span></span></p>
<p><span style="color: #ff0000;">[Proximity sensor, motors and wheels]</span></p>
<p><span style="color: #ff0000;">We run the simulation and notice that the robot is falling backwards. We are still missing a third contact point to the floor. We now add a small slider (or caster). In a new scene we and add a pure primitive sphere with diameter 0.05 and make the sphere Collidable, Measurable, Renderable and Detectable (if not already enabled), then rename it to bubbleRob_slider. We set the Material to noFrictionMaterial in the shape dynamics properties. To rigidly link the slider with the rest of the robot, we add a force sensor object with [Menu bar --&gt; Add --&gt; Force sensor]. We rename it to bubbleRob_connection and shift it up by 0.05. We attach the slider to the force sensor, then copy both objects, switch back to scene 1 and paste them. We then shift the force sensor by -0.07 along the absolute X-axis, then attach it to the robot body. If we run the simulation now, we can notice that the slider is slightly moving in relation to the robot body: this is because both objects (i.e. bubbleRob_slider and bubbleRob) are colliding with each other. To avoid strange effects during dynamics simulation, we have to inform CoppeliaSim that both objects do not mutually collide, and we do this in following way: in the shape dynamics properties, for bubbleRob_slider we set the local respondable mask to 00001111, and for bubbleRob, we set the local respondable mask to 11110000. If we run the simulation again, we can notice that both objects do not interfere anymore. This is what we now have:</span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;">我們運行模擬，並注意到機器人向後倒下。我們仍然缺少與地板的第三個接觸點。現在，我們添加一個小的滑塊（或腳輪）。在一個新場景中，我們添加一個直徑為0.05的球體，並使該球體可碰撞，可測量，可渲染和可檢測（如果尚未啟用），然後將其重命名為bubbleRob_slider。我們在形狀動力學屬性中將Material設置為noFrictionMaterial。為了將滑塊與機器人的其餘部分牢固地鏈接在一起，我們使用[菜單欄-&gt;添加-&gt;力傳感器]添加了力傳感器對象。我們將其重命名為bubbleRob_connection並將其上移0.05。我們將滑塊連接到力傳感器，然後復制兩個對象，切換回場景1並貼上它們。然後，我們將力傳感器沿絕對X軸移動-0.07，然後將其安裝到機器人主體上。如果現在運行仿真，我們會注意到滑塊相對於機器人主體略微移動：這是因為兩個對象（即bubbleRob_slider和bubbleRob）彼此碰撞。為了避免在動力學模擬過程中產生奇怪的影響，我們必須通知CoppeliaSim兩個對像不會相互碰撞，我們可以通過以下方式進行此操作：在形狀動力學屬性中，對於bubbleRob_slider，我們將本地可響應模版設置為00001111，對於bubbleRob，我們將本地可響應掩碼設置為11110000。如果再次運行機器人，我們會注意到兩個對像不再相互干擾。這就是我們現在擁有的：</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;"><img alt="" height="538" src="/images/4.png" width="729"/></span></span></p>
<p><span style="color: #ff0000;">[Proximity sensor, motors, wheels and slider]</span></p>
<p><span style="color: #ff0000;">We run the simulation again and notice that BubbleRob slightly moves, even with locked motor. We also try to run the simulation with different physics engines: the result will be different. Stability of dynamic simulations is tightly linked to masses and inertias of the involved non-static shapes. For an explanation of this effect, make sure to carefully read this and that sections. We now try to correct for that undesired effect. We select the two wheels and the slider, and in the shape dynamics dialog we click three times M=M*2 (for selection). The effect is that all selected shapes will have their masses multiplied by 8. We do the same with the inertias of the 3 selected shapes, then run the simulation again: stability has improved. In the joint dynamics dialog, we set the Target velocity to 50 for both motors. We run the simulation: BubbleRob now moves forward and eventually falls off the floor. We reset the Target velocity item to zero for both motors.</span></p>
<p>我們再次運行機器人，發現即使在電機鎖定的情況下，BubbleRob也會輕微移動。我們還嘗試使用不同的物理引擎運行機器人：結果將有所不同。動態仿真的穩定性與所涉及的非靜態形狀的質量和慣性緊密相關。有關此效果的說明，請務必仔細閱讀本節和該節。現在，我們嘗試糾正這種不良影響。我們選擇兩個輪子和滑塊，然後在“動力學”對話框中單擊3次M = M * 2（用於選擇）。效果是所有選定形狀的質量都將乘以8。我們對3個選定形狀的慣性進行相同的操作，然後再次運行仿真：穩定性得到了改善。在關節動力學對話框中，我們將兩個電機的目標速度都設置為50。我們運行模擬：BubbleRob現在向前移動並最終掉落在地板上。我們將兩個電機的目標速度項都重置為零。</p>
<p><span style="color: #ff0000;">The object bubbleRob is at the base of all objects that will later form the BubbleRob model. We will define the model a little bit later. In the mean time, we want to define a collection of objects that represent BubbleRob. For that we define a collection object. We click [Menu bar --&gt; Tools --&gt; Collections] to open the collection dialog. Alternatively we can also open the dialog by clicking the appropriate toolbar button:</span></p>
<p>對象bubbleRob是所有對象的基礎，所有對象隨後將形成BubbleRob模型。我們將在稍後定義模型。同時，我們要定義代表BubbleRob的對象的集合。為此，我們定義了一個收集對象。我們單擊[Menu bar --&gt; Tools --&gt; Collections]以打開集合對話框。或者，我們也可以通過單擊相應的工具欄按鈕來打開對話框：</p>
<p><img alt="" height="76" src="/images/5.png" width="110"/></p>
<p><span style="color: #ff0000;">In the collection dialog, we click Add new collection. A new collection object appears in the list just below. For now the newly added collection is still empty (not defined). While the new collection item is selected in the list, select bubbleRob in the scene hierarchy, and then click Add in the collection dialog. Our collection is now defined as containing all objects of the hierarchy tree starting at the bubbleRob object (the collection's composition is displayed in the Composing elements and attributes section). To edit the collection name, we double-click it, and rename it to bubbleRob_collection. We close the collection dialog.</span></p>
<p>在集合對話框中，單擊添加新集合。一個新的集合對像出現在下面的列表中。目前，新添加的集合仍為空（未定義）。在列表中選擇新的收藏項時，在場景層次中選擇bubbleRob，然後在收藏對話框中單擊“添加”。現在，我們的集合被定義為包含層次結構樹的所有對象（從bubbleRob對像開始）（集合的組成顯示在“組成元素和屬性”部分中）。要編輯集合名稱，請雙擊它，然後將其重命名為bubbleRob_collection。我們關閉收集對話框。</p>
<p><span style="color: #ff0000;">At this stage we want to be able to track the minimum distance between BubbleRob and any other object. For that, we open the distance dialog with [Menu bar --&gt; Tools --&gt; Calculation module properties]. Alternatively we can also open the calculation module properties dialog with the appropriate toolbar button:</span></p>
<p>在此階段，我們希望能夠跟踪BubbleRob與任何其他對象之間的最小距離。為此，我們使用[Menu bar --&gt; Tools --&gt; Calculation module properties]打開距離對話框。或者，我們也可以使用相應的工具欄按鈕打開計算模塊屬性對話框：</p>
<p><img alt="" height="110" src="/images/6.png" width="177"/></p>
<p><span style="color: #ff0000;">In the distance dialog, we click Add new distance object and select a distance pair: [collection] bubbleRob_collection - all other measurable objects in the scene. This just added a distance object that will measure the smallest distance between collection bubbleRob_collection (i.e. any measurable object in that collection) and any other measurable object in the scene. We rename the distance object to bubbleRob_distance with a double-click in its name. We close the distance dialog. When we now run the simulation, we won't see any difference, since the distance object will try to measure (and display) the smallest distance segment between BubbleRob and any other measurable object in the scene. The problem is that at this stage there is no other measurable object in the scene (the shape defining the floor has its measurable property turned off by default). At a later stage in this tutorial, we will add obstacles to our scene.</span></p>
<p>在距離對話框中，單擊“添加新距離對象”並選擇一個距離對：[collection] bubbleRob_collection-場景中所有其他可測量對象。這只是添加了一個距離對象，該距離對象將測量集合bubbleRob_collection（即該集合中的任何可測量對象）與場景中任何其他可測量對象之間的最小距離。我們通過雙擊其名稱將距離對象重命名為bubbleRob_distance。我們關閉距離對話框。現在，當我們運行模擬時，我們不會看到任何區別，因為距離對象將嘗試測量（並顯示）BubbleRob與場景中任何其他可測量對象之間的最小距離段。問題在於，在此階段，場景中沒有其他可測量的對象（定義地板的形狀默認情況下已禁用其可測量的屬性）。在本教程的後續階段，我們將為場景添加障礙。</p>
<p><span style="color: #ff0000;">Next we are going to add a graph object to BubbleRob in order to display above smallest distance, but also BubbleRob's trajectory over time. We click [Menu bar --&gt; Add --&gt; Graph] and rename it to bubbleRob_graph. We attach the graph to bubbleRob, and set the graph's absolute coordinates to (0,0,0.005). Now we open the graph properties dialog by double-clicking its icon in the scene hierarchy. We uncheck Display XYZ-planes, then click Add new data stream to record and select Object: absolute x-position for the Data stream type, and bubbleRob_graph for the Object / item to record. An item has appeared in the Data stream recording list. That item is a data stream of bubbleRob_graph's absolute x-coordinate (i.e. the bubbleRobGraph's object absolute x position will be recorded). Now we also want to record the y and z positions: we add those data streams in a similar way as above. We now have 3 data streams that represent BubbleRob's x-, y- and z-trajectories. We are going to add one more data stream so that we are able to track the minimum distance between our robot and its environment: we click Add new data stream to record and select Distance: segment length for the Data stream type, and bubbleRob_distance for the Object / item to record. In the Data stream recording list, we now rename Data to bubbleRob_x_pos, Data0 to bubbleRob_y_pos, Data1 to bubbleRob_z_pos, and Data2 to bubbleRob_obstacle_dist.</span></p>
<p>接下來，我們將向BubbleRob添加一個圖形對象，以顯示最小距離以上的距離，同時還顯示BubbleRob隨時間的軌跡。我們單擊[Menu bar --&gt; Add --&gt; Graph]，並將其重命名為bubbleRob_graph。我們將圖形附加到bubbleRob，並將圖形的絕對坐標設置為（0,0,0.005）。現在，通過在場景層次結構中雙擊其圖標來打開圖形屬性對話框。我們取消選中“顯示XYZ平面”，然後單擊“添加新數據流以進行記錄”，然後選擇“對象：數據流類型的絕對x位置”，並選擇“ bubbleRob_graph”作為要記錄的對象/項目。數據流記錄列表中出現了一個項目。該項目是bubbleRob_graph的絕對x坐標的數據流（即，將記錄bubbleRobGraph的對象的絕對x位置）。現在，我們還想記錄y和z位置：我們以與上述類似的方式添加這些數據。現在，我們有3個數據，分別表示BubbleRob的x，y和z軌跡。我們將再添加一個數據流，以便能夠跟踪機器人與其環境之間的最小距離：單擊添加新數據流以進行記錄，然後選擇“距離：數據流類型的段長度”和“氣泡Rob_distance”作為要記錄的對象/項目。在數據流記錄列表中，我們現在將Data重命名為bubbleRob_x_pos，將Data0重命名為bubbleRob_y_pos，將Data1重命名為bubbleRob_z_pos，將Data2重命名為bubbleRob_obstacle_dist。</p>
<p><span style="color: #ff0000;">We select bubbleRob_x_pos in the Data Stream recording list and in the Time graph properties section, uncheck Visible. We do the same for bubbleRob_y_pos and bubbleRob_z_pos. By doing so, only the bubbleRob_obstacle_dist data stream will be visible in a time graph. Following is what we should have:</span></p>
<p>我們在“數據流”記錄列表中和“時間圖屬性”部分中選擇bubbleRob_x_pos，取消選中“可見”。我們對bubbleRob_y_pos和bubbleRob_z_pos都執行相同的操作。這樣，在時間圖中只能看到bubbleRob_obstacle_dist數據流。以下是我們應該擁有的：</p>
<p><img alt="" height="663" src="/images/7.png" width="561"/></p>
<p><span style="color: #ff0000;">[Graph properties]</span></p>
<p><span style="color: #ff0000;">Next we will set-up a 3D curve that displays BubbleRob's trajectory: we click Edit 3D curves to open the XY graph and 3D curve dialog, then click Add new curve. In the dialog that pops open, we select bubbleRob_x_pos for the X-value item, bubbleRob_y_pos for the Y-value item and bubbleRob_z_pos for the Z-value item. We rename the newly added curve from Curve to bubbleRob_path. Finally, we check the Relative to world item and set Curve width to 4:</span></p>
<p>接下來，我們將建立一個顯示BubbleRob軌蹟的3D曲線：單擊“編輯3D曲線”以打開XY圖形和3D曲線對話框，然後單擊“添加新曲線”。在彈出的對話框中，我們為X值項目選擇bubbleRob_x_pos，為Y值項目選擇bubbleRob_y_pos，為Z值項目選擇bubbleRob_z_pos。我們將新添加的曲線從Curve重命名為bubbleRob_path。最後，我們檢查“相對於世界”項目並將“曲線寬度”設置為4：</p>
<p><img alt="" height="383" src="/images/8.png" width="583"/></p>
<p>[<span style="color: #ff0000;">3D curve properties]</span></p>
<p><span style="color: #ff0000;">We close all dialogs related to graphs. Now we set one motor target velocity to 50, run the simulation, and will see BubbleRob's trajectory displayed in the scene. We then stop the simulation and reset the motor target velocity to zero.</span></p>
<p>我們關閉與圖有關的所有對話框。現在我們將一個電機目標速度設置為50，運行模擬，然後將看到BubbleRob的軌跡顯示在場景中。然後，我們停止仿真並將電動機目標速度重置為零。</p>
<p><span style="color: #ff0000;">We add a pure primitive cylinder with following dimensions: (0.1, 0.1, 0.2). We want this cylinder to be static (i.e. not influenced by gravity or collisions) but still exerting some collision responses on non-static respondable shapes. For this, we disable Body is dynamic in the shape dynamics properties. We also want our cylinder to be Collidable, Measurable, Renderable and Detectable. We do this in the object common properties. Now, while the cylinder is still selected, we click the object translation toolbar button:</span></p>
<p>我們添加具有以下尺寸的純原始圓柱體：（0.1，0.1，0.2）。我們希望此圓柱體是靜態的（即不受重力或碰撞的影響），但仍會對非靜態的可響應形狀施加一些碰撞響應。為此，我們在形狀動力學屬性中禁用“主體是動態的”。我們還希望圓柱體是可碰撞的，可測量的，可渲染的和可檢測的。我們在對象的公共屬性中執行此操作。現在，在仍選擇圓柱體的情況下，我們單擊對象平移工具欄按鈕：</p>
<p><img alt="" height="44" src="/images/9.png" width="331"/></p>
<p><span style="color: #ff0000;">Now we can drag any point in the scene: the cylinder will follow the movement while always being constrained to keep the same Z-coordinate. We copy and paste the cylinder a few times, and move them to positions around BubbleRob (it is most convenient to perform that while looking at the scene from the top). During object shifting, holding down the shift key allows to perform smaller shift steps. Holding down the ctrl key allows to move in an orthogonal direction to the regular direction(s). When done, select the camera pan toolbar button again:</span></p>
<p>現在我們可以拖動場景中的任何點：圓柱體將跟隨運動，同時始終受約束以保持相同的Z坐標。我們複製並粘貼圓柱幾次，然後將它們移動到BubbleRob周圍的位置（從頂部查看場景時執行該操作最方便）。在對象移動期間，按住Shift鍵可以執行較小的移動步驟。按住ctrl鍵可以在與常規方向正交的方向上移動。完成後，再次選擇相機平移工具欄按鈕：</p>
<p><img alt="" height="40" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKwAAAAoCAYAAABjEBEWAAANrUlEQVR4Xu2ce5AU1RXGv37Pex8goPwZY1lWECHrUigQNBgxiGJKK6FCyogCsiDPBZa3gLgPHitkgw8iisoqEAoEpMpUNEXQAhVSqSC+ESMoywrs7M5MT8/0dHfqnN7GjQ/4Y0LRpvpWTU3tzM7tu3d//c13zj33Co7jOAhaMAM/kBkQAmB/IP+pYJg8AwGw/4cgtLe34/Dhw9i3bx//dbZtg75I4/E4stksBEH4/r9aKECWCshkMghpJQBECIID27YAUYAoKLAt2f28UAAE0312ZMCOAY4IyzYQiaowDIOvN3ToUFRUVPD1i20BsMXOoA8/v3//fmzZsgWNjY0oFAoMq6IoDE8oFIJpmucFFo4BVQ0jnwMDqIYUGNkMBEmApkbc178T2CjgAIoK6NkM8vk8ysrKUF9fj759+2L48OFFz1YAbNFT6L8Oli5dikWLFrHCEaAELTVd1xEOhyGK4nmBzeXTiIRiyOclBlYQLSiKhIyeQjgUhWN7Cmt9Q2FDDGzBsqCFJL4G3SRHjx7Fnj17MHv27KInKwC26Cn0XwekaFOnToWqqgznmTNnUFpaCklyIcrlPIn8rrHbrJDt7WmUJi4DsU4Owixk4TgWNE1DwewE/luWIMIWwkGeAadGKkuWpKmpCXPmzCl6sgJgi55C/3WwcuVKTJw4kQGlB9mB06dPIxqNMjykut/fbBSsPDQ1io6khUTCBS+dMRCLq6zSmhrrtASksKTeFoMK2+1XksG2g2Cla37wwQfYvHkzFi9eXPRkBcAWPYX+62D58uWYP38+Q2NZFitqSUkJfz2TJTi/wgKapuDM6RTSHTaam7dg4A0/xaDBFbCdPKssHLUTWBsASTABS9FdmCIx/pkCNQru6PoUwK1fvx41NTVFT1YAbNFT6L8OCNhZs2YxMKSopLCe4hGwF0q958w82tsMrGl8Gt3Ke+LTYx9i9G9H4foBP0EkrKJgCuxtubEtcD0yg0yvCzZsu8D2gdqRI0ewfft2LFiwoOjJCoAtegr918GqVavw4IMPMjCkcAQtPcdiMaTTafa252snW1rRUL8Ggwb+EldeeTXee/+fOHhoH351zy9QWdkfikTBlRd4eSprn1NeUmEvdZZKpfgG2bhxI2bOnFn0ZAXAFj2F/uugrq6O4SBICRzvQdkC8rT0M0FE7xO8lE2IRCJsFVpaWtCwYhWG3XInupddiWg0AREm3v/wIF7fuwP3jR2Da/v0Y49L7oBuBsoIEKSm+TWoLLiOawuoT/KwQZbAf6z4YkTnA5ayBgyZprHaEqiyLOPs2bMoLy/HjOqZMC0B7W05TBw/F7FoObL6WTy5fjUsnEEoLKBx9VpIkgbRUbgPSRagKAJkuTMo67QCdB26XgCsL7Dw7yC+CSxbTUHgfCwpLMGaTCY5ACNYCTpSQ0p9kX/VjQLmzVuGqvELoGdMiGIeLzQ/gYYVNbCdDARBgVUAoqEYMhnKBKhItiehqTL3bRbIJrjqGwDrX058MzLKw86YMYMB9bykF7ETsBSAkbJS2omA8tJfBLEoSwhH45g8eQ5+N3o6BKiQJBPrnmjA408sAcQsRMENvEQnhHBYxeefn0Cvy7sjFFKhZ1IQJcXNx3axBLTyFlgC3yDir4F0BdYbWVdgCVCqNyBoyceS0lLqidRRUmR0pNNYuLAe99w1GYl4N0hyAeuerMPqx+ZA0xzksnnIUhi2qcKxJURjInJ5Ezmjww3oBPK0rk/uqrDBwoG/OPHNaDxgu9YMdAWWvqopoe/lY2kxgDIIrLiyBMtxMHPmYtx/7zwoUgwFO4Wmxx9F07qFyJltUCUNkVAZA6tn8lzoksvrgJPjfowc1Sq4ChsA6xss/DuQCwFLWYF3330XL774Impra88tKpDaUkUWZAHjJ8zCjEm1gK0xsOs3rMJTTy1FtnAagkU1BhrsfBiKrOKhKZM5ezCg8jr2w4pKK14usKTmXtAVKKx/mbmkIyNgp0+ffq5Syy0RFMAVgrKEgwcP4plnnuVyP/rdfK7AiwucihIdWJKFSROrMWnCwwys5ejY8OxjWN1Ywx5WFjV0JHPo1b0H0mkHs2dXw7JzuOfuuzBkyCC2GV5aixT21KlTnNYKgL2kWPj34nV1j6K6ejarZTqlQ1VDMIwcopEY9u47gK1b/4xBg4bg9b/thSQpMC2bU1JuZVYBppNBLFqCu0eNZw9LNa+U1jKtVn5fFcMw86SeKmcCJEHAoME34MCBAxg5cgRuGjKQcgR8w5CnPXnyJJqbmzFv3ryiJy1YOCh6Cv3XQW3tclRXVyOtZxHSKBtQQDwWwd59h/DSS5sxZPDN+NGPr0IkHEdbewplZd3QkcpAFCUUrBwkxV21ss0EBEFGW7IV3S+LQtVyMHJpSFD5dccW4MCC4LhLs//+7AT+vvevuO22Qbhl2M/YDpD98BQ2ANZ/rPhiRPX1tZzWopWnQsFGPBHD8eMtmFuzENf1r8CNNw5BJBpHR0casUQJLMtBVs8xuOlMFpYtQRbjCMka51sFETDyJgQhzXUDqhRCwaQaWY2DqnQqifLyUhw79jmOvPcPtJw6jOrqKiQSCVZg8rXPPfdcUPziCzp8OIiVKxtQVVXFsLp5VwuqFsYnHx9DY+MajBx5J3pd0Ru2JSIcjUDXDcRLStF6shWl5T2QSueQiF0OPaWgYAKRKCDLFgzzNMJhBaZhMeSRcBRGVkc0pjGYn3z8GV5/bRfuuHMwbh42kPO99KCUGdUSUAVZsS2wBMXOoA8/v/yRpRzg5AwTikZF3DJaTrairKwc+w+8jY0bn8eIO0bijX37O+sIYmjv6EA8mkBaz0CQJUhCBPfdOxWlJaVo72jDn9avhRbOw8ilAFtELJZA29l2xKNhTmkNHToEf3n1NYwb/wAqr78Wkuywh6UAjJZ9t27dyjal2BYAW+wM+vDzax5bjXHjxkGRNd5tIMoKunfvjvZkCqqq4dChQ3h24/Oc3F/7xyYGm7xmNBqDKAqQNQFVk6Zj3P3VbAnKSiJoXPMIahvmIxwSIUshZDJZKKICWRYxbXoVZxxIuSsrBjCkZAOoBtfLw77yyiuYMmVK0bMVAFv0FPqvg0eXLuGIPNmR5gUCgpH8Jn1tZ3SDB/zRRx9h167dmDipCj169EAoJKE9aUCQBei5NBYvegQTx8+BAAVffXUC21/ehPoVC2CZOvJ5G7FoHKqiIJXqwNJlC3D77bejoqKSYVbkEAd6BCtZgi+++AK7d+8Olmb9h4o/RrS6oZ7VzIbIW1q86iz2sqoKR3A3B1Julna1tiWT/DuU/uIVMViombsID9xXjaxuolt5DGub6rBs2QyEwrTsKkESZRh6DpFoCGZBhyQJyGULvEkxa5gIhdxaBVruJZXftGlTEHT5Aw//jaKhrp7rYelr2dsh6y2Tes/0XigS7gzKTK7aombZQMGWsHhhHe4dMxXZbB7xqMp52NqGubxB0aYdBxAg8O4CWiSgVAKlwmgXgkilBOcqw+hG6Ojo4DxssEXGf6z4YkQELKW1KDr3irc5wS+ROjr8IKXVjQyP1yveJjVW1AhXaM2sfhgPVS3kcwisAq10/QE18yajpDQCM0f7ukTavcULBC60VFLYuW2GVsssk68XAOsLJPw9CK+WwFNYb2+Xp7a6nmbfSraA/C0FSfQe1cNadNKao2DChGpMmjiXPezp1hPYum0j1m9oQMupk4hodIJLp8L+F7CuSrsKmz93gwQK629eLvnovALurpbAK6amwRGchqEzsORhvfMLjh07hqZ1j6MtqSMR74kxo6sQCSegyDae3tCE1jNH0evybphfs+i8wKKLwpKaB8BeciT8PYDauoZzHtYr4GZLwCe+0I7Wr+0BBUUEFD2TNXjjzf3YvedV9OkzABXX/RzJtjSiMQUtrZ9i587nMWrUSFRWDnQtAW9EtCGwh3UAh84wsCFwDvZrhaWNiIGH9Tczl3R0HrAEimcDPGDdzYfujgNSWKrSIqhJjQlaByIOvPM2mpt3YOTwMbjmmj44fuJTvLyrGaN/MwIDb7iea2AByQ26WGu9s7q+7WE9haVSxiDouqRY+PfiBCwFXQRhV4UleAkgN4WlcgE3vRYJh9nL0spUJBaGLRTwr8MfomnNC7hp6DC88/ab+P3YX+Oqq69A1kghFk6wmnrA8gmG1FhhRe6T+qLMQwCsfznxzcguBCzH9rbNW2MI1Jxh8EoVgUaZA1FxoOs5vHf4OHbsoNqA21A5oC8k0eDt3LRCdg5YSmfxUUXUOg+PEyQO5LyzvMhyBArrGzz8NxA6W2vs2LHuDlbTZDjJArS1tTGYFzqqyGEIxc7DMih55XCVluBQCsvLt3L41pnO6joHrrpSxoHO86Kg7ssvv8TOnTtZ9YttwdJssTPow8/ToWtLlizB8ePH+avf201AeVlSVU/5LtbQPd9MNwvdHHTDbNiwITgM7mJN+A+93xUrVvAWGVoS5UCq85QX8rOktBSMXczmpdBoQyLdJGQ7tm3bhmnTphV92UBhi55C/3VAhSZ0ZDzZAoK1tbUVvXv35vQVre8TtBezeYEeZSEIWqqF7devH2699daiLxsAW/QU+q8Dyg689dZbvMeKAO3Zsyf7SPKV9HVNr13M5p11QEpLKj9ixAj079//f3KjBMBezP9c0Pf/fAb+AyPBm/JYBpV2AAAAAElFTkSuQmCC" width="172"/></p>
<p><span style="color: #ff0000;">We set a target velocity of 50 for the left motor and run the simulation: the graph view now displays the distance to the closest obstacle and the distance segment is visible in the scene too. We stop the simulation and reset the target velocity to zero.</span></p>
<p>我們將左馬達的目標速度設置為50並運行模擬：現在，圖形視圖顯示了到最近障礙物的距離，並且該距離段在場景中也可見。我們停止模擬並將目標速度重置為零。</p>
<p><span style="color: #ff0000;">We now need to finish BubbleRob as a model definition. We select the model base (i.e. object bubbleRob) then check items Object is model base and Object/model can transfer or accept DNA in the object common properties: there is now a stippled bounding box that encompasses all objects in the model hierarchy. We select the two joints, the proximity sensor and the graph, then enable item Don't show as inside model selection and click Apply to selection, in the same dialog: the model bounding box now ignores the two joints and the proximity sensor. Still in the same dialog, we disable camera visibility layer 2, and enable camera visibility layer 10 for the two joints and the force sensor: this effectively hides the two joints and the force sensor, since layers 9-16 are disabled by default. At any time we can modify the visibility layers for the whole scene. To finish the model definition, we select the vision sensor, the two wheels, the slider, and the graph, then enable item Select base of model instead: if we now try to select an object in our model in the scene, the whole model will be selected instead, which is a convenient way to handle and manipulate the whole model as a single object. Additionally, this protects the model against inadvertant modification. Individual objects in the model can still be selected in the scene by click-selecting them with control-shift, or normally selecting them in the scene hierarchy. We finally collapse the model tree in the scene hierarchy. This is what we have:</span></p>
<p>現在，我們需要完成BubbleRob作為模型定義。我們選擇模型基礎（即對象bubbleRob），然後選中``對像是模型基礎''，然後選擇``對象/模型可以轉移或接受對象共同屬性中的DNA''：現在有一個點畫的邊界框包含模型層次結構中的所有對象。我們選擇兩個關節，即接近傳感器和圖形，然後啟用項目“不顯示為內部模型選擇”，然後在同一對話框中單擊“應用於選擇”：模型邊界框現在將忽略兩個關節和接近傳感器。仍在同一對話框中，我們禁用攝像機可見性層2，並為兩個關節和力傳感器啟用攝像機可見性層10：這有效地隱藏了兩個關節和力傳感器，因為默認情況下禁用第9-16層。我們可以隨時修改整個場景的可見性層。要完成模型定義，我們選擇視覺傳感器，兩個輪子，滑塊和圖形，然後啟用“選擇模型基礎”選項：如果現在嘗試在場景中選擇模型中的對象，則整個模型而是選擇，這是一種將單個模型處理和操縱整個模型的便捷方法。此外，這可以防止模型受到意外修改。仍然可以通過在按住Shift的同時單擊選擇對像或在場景層次結構中正常選擇它們，來在場景中選擇模型中的單個對象。最後，我們將模型樹折疊到場景層次中。這就是我們所擁有的：</p>
<p><img alt="" height="526" src="/images/11.png" width="752"/></p>
<p><span style="color: #ff0000;">[BubbleRob model definition]</span></p>
<p><span style="color: #ff0000;">Next we will add a vision sensor, at the same position and orientation as BubbleRob's proximity sensor. We open the model hierarchy again, then click [Menu bar --&gt; Add --&gt; Vision sensor --&gt; Perspective type], then attach the vision sensor to the proximity sensor, and set the local position and orientation of the vision sensor to (0,0,0). We also make sure the vision sensor is not not visible, not part of the model bounding box, and that if clicked, the model will be selected instead. In order to customize the vision sensor, we open its properties dialog. We set the Far clipping plane item to 1, and the Resolution x and Resolution y items to 256 and 256. We add a floating view to the scene, and over the newly added floating view, right-click [Popup menu --&gt; View --&gt; Associate view with selected vision sensor] (we make sure the vision sensor is selected during that process).</span></p>
<p>接下來，我們將在與BubbleRob接近傳感器相同的位置和方向上添加視覺傳感器。我們再次打開模型層次結構，然後單擊[Menu bar --&gt; Add --&gt; Vision sensor --&gt; Perspective type]，然後將視覺傳感器連接到接近傳感器，並將視覺傳感器的本地位置和方向設置為（0,0,0）。我們還確保視覺傳感器不可見，不是模型邊界框的一部分，並且如果單擊該模型，則會選擇模型。為了自定義視覺傳感器，我們打開其屬性對話框。將“遠裁剪平面”項設置為1，將“分辨率x”和“分辨率y”項設置為256和256。向場景中添加一個浮動視圖，並在新添加的浮動視圖上，右鍵單擊[Popup menu --&gt; View --&gt; Associate view with selected vision sensor]（我們確保在該過程中選擇了視覺傳感器）。</p>
<p><span style="color: #ff0000;">We attach a non-threaded child script to the vision sensor by clicking [Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]. We double-click the little icon that appeared next to the vision sensor in the scene hierarchy: this opens the child script that we just added. We copy and paste following code into the script editor, then close it:</span></p>
<p>通過單擊[Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]，將非線程子腳本附加到視覺傳感器。我們雙擊場景層次結構中視覺傳感器旁邊出現的小圖標：這將打開我們剛剛添加的子腳本。我們將以下代碼複製並粘貼到腳本編輯器中，然後將其關閉：</p>
<p><img alt="" height="146" src="/images/12.png" width="1033"/></p>
<p><span style="color: #ff0000;">To be able to see the vision sensor's image, we start the simulation, then stop it again.</span></p>
<p>為了能夠看到視覺傳感器的圖像，我們開始模擬，然後再次停止。</p>
<p><span style="color: #ff0000;">The last thing that we need for our scene is a small child script that will control BubbleRob's behavior. We select bubbleRob and click [Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]. We double-click the script icon that appeared next to bubbleRob's name in the scene hierarchy and copy and paste following code into the script editor, then close it:</span></p>
<p>我們場景所需的最後一件事是一個小的子腳本，它將控制BubbleRob的行為。我們選擇bubbleRob並單擊[Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]。我們雙擊場景層次結構中bubbleRob名稱旁邊顯示的腳本圖標，然後將以下代碼複製並粘貼到腳本編輯器中，然後將其關閉：</p>
<p><img alt="" height="681" src="/images/13.png" width="1036"/></p>
<p><span style="color: #ff0000;">We run the simulation. BubbleRob now moves forward while trying to avoid obstacles (in a very basic fashion). While the simulation is still running, change BubbleRob's velocity, and copy/paste it a few times. Also try to scale a few of them while the simulation is still running. Be aware that the minimum distance calculation functionality might be heavily slowing down the simulation, depending on the environment. You can turn that functionality on and off in the distance dialog, by checking / unchecking the Enable all distance calculations item.</span></p>
<p>我們運行模擬。 BubbleRob現在在嘗試避開障礙物的同時向前移動（以非常基本的方式）。在模擬仍在運行時，更改BubbleRob的速度，然後將其複制/粘貼幾次。在模擬仍在運行時，也嘗試擴展其中的一些。請注意，根據環境的不同，最小距離計算功能可能會嚴重降低仿真速度。您可以通過選中/取消選中“啟用所有距離計算”項來在“距離”對話框中打開和關閉該功能。</p>
<p><span style="color: #ff0000;">Using a script to control a robot or model is only one way of doing. CoppeliaSim offers many different ways (also combined), have a look at the external controller tutorial.</span></p>
<p>使用腳本控制機器人或模型只是一種方法。 CoppeliaSim提供了許多不同的方法（也可以結合使用），請參閱外部控制器教程。</p>
<h2>Line following</h2>
<p><span style="color: #0000ff;">由40723243提供</span></p>
<p><strong><span style="color: #ff0000;">Line following BubbleRob tutorial</span> </strong><br/><strong>使 BubbleRob 沿著固定軌跡的教程</strong></p>
<p><br/><span style="color: #ff0000;">In this tutorial we aim at extending the functionality of BubbleRob to let him/her follow a line on the ground. Make sure you have fully read and understood the first BubbleRob tutorial. This tutorial is courtesy of Eric Rohmer.</span> <br/>在本教程中，我們要擴展 BubbleRob 的功能，以使他遵循地面上的軌跡。確保您已經<br/>閱讀並理解了第一個 BubbleRob 教程。本教程由 Eric Rohmer 提供。 <br/><span style="color: #ff0000;">Load the scene of the first BubbleRob tutorial located in CoppeliaSim's installation folder, in tutorials/BubbleRob. The scene file related to this tutorial is located in tutorials/LineFollowingBubbleRob. Following figure illustrates the simulation scene that we will design:</span></p>
<p><br/>在 CoppeliaSim 的安裝文件夾中的 tutorials / BubbleRob 中加載第一個 BubbleRob 教程的場景。與本教程相關的場景文件位於 tutorials / LineFollowing BubbleRob 中。下圖說明了我們將設計的仿真場景：</p>
<p><img alt="" height="474" src="/images/a.PNG" width="732"/></p>
<p><span style="color: #ff0000;">We first create the first of 3 vision sensors that we will attach to the bubbleRob object. Select [Menu bar --&gt; Add --&gt; Vision sensor --&gt; Orthographic type]. Edit its properties, by double-clicking on the newly created vision sensor icon in the scene hierarchy, and change the parameters to reflect following dialog:</span></p>
<p><br/>我們首先創建三個視覺傳感器中的第一個，並將其附加到 bubbleRob 物件中。選擇<br/>[Menu bar -&gt; Add -&gt; Vision sensor -&gt; Orthographic type]。通過雙擊場景中新創建的視覺傳感器圖標來編輯其屬性，並更改參數以反映以下對話框：</p>
<p><img alt="" height="584" src="/images/b.PNG" width="385"/></p>
<p><span style="color: #ff0000;">The vision sensor has to be facing the ground, so select it, and in the orientation dialog, on the orientation tab, set [180;0;0] for the Alpha-Beta-Gamma items.</span> <br/> <br/>視覺傳感器必須面向地面，因此選擇它，然後在“orientation”對話框中的<br/>“orientation”選項上，將“ Alpha-Beta-Gamma”項設置為[180; 0; 0]。 <br/> <br/><span style="color: #ff0000;">We have several possibilities to read a vision sensor. Since our vision sensor has just one pixel and operates in an easy way, we will simply query the average intensity value of the image read by our vision sensor. For more complex cases, we could have set-up a vision callback function. Now copy and paste the vision sensor twice, and adjust its names to leftSensor, middleSensor and rightSensor. Make bubbleRob their parent (i.e. attach them to the bubbleRob object). Your sensors should now look like this in the scene hierarchy:</span> <br/> <br/>我們有幾種可能可以讀取視覺傳感器的方式。由於我們的視覺傳感器只有一個像素，<br/>並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更<br/>複雜的情況，我們可以設置視覺回調函數。現在，複製並貼上視覺傳感器兩次，並將<br/>其名稱調整為 leftSensor，middleSensor 和 rightSensor。將 bubbleRob 設置為其父級<br/>（即，將其附加到 bubbleRob 對象）。現在，您的傳感器在場景層次中應如下所示：</p>
<p><img alt="" height="255" src="/images/c.PNG" width="248"/></p>
<p><span style="color: #ff0000;">Let's position the sensors correctly. For that use the position dialog, on the position tab, and set following absolute coordinates:</span></p>
<p><br/>讓我們正確放置傳感器。為此，使用位置對話框，在位置選項上，並設置以下絕對坐標： <br/>左傳感器：[0.2; 0.042; 0.018]</p>
<p>中間傳感器：[0.2; 0; 0.018]</p>
<p>右傳感器：[0.2; -0.042; 0.018] </p>
<p><img alt="" height="109" src="/images/d.PNG" width="412"/><br/> <br/><span style="color: #ff0000;">Now let's modify the environment. We can remove a few cylinders in front of BubbleRob. Next, we will build the path that the robot will try to follow. It is probaby better to switch to a top view from now on: select page 4 via the page selector toolbar button. Then click [Menu bar --&gt; Add --&gt; Path --&gt; Circle type]. Enable the object movement with the mouse. You have two possibilities to adjust the shape of the path:</span> <br/> <br/>現在我們可以修改環境。我們可以移去 BubbleRob 前面的幾個圓柱體。接下來，我們<br/>將構建機器人將嘗試使機器人遵循的路徑。從現在開始最好切換到頂視圖：通過頁面<br/>選擇器工具欄按鈕選擇頁面 4。然後單擊[菜單欄-&gt;添加-&gt;路徑-&gt;圓圈類型]。使用鼠標<br/>啟用對象移動。您可以通過兩種方式調整路徑的形狀： <br/> <br/>1. 選擇路徑（並且只有路徑）後，按住 Ctrl 並單擊其控制點之一。然後可以將它們<br/>拖動到正確的位置。 <br/>2. 選擇路徑後，進入路徑編輯模式。在那裡，您可以自由地調整各個路徑控制點。 <br/> <br/><span style="color: #ff0000;">Once you are satisfied with the geometry of the path (you can always modify it at a later stage), select it, and uncheck Show orientation of points, Show path line and Show current position on path in the path properties. Then click Show path shaping dialog. This opens the path shaping dialog. Click Path shaping enabled, set the type to horizontal segment, and Scaling factor to 4.0. Finally adjust the color to black. There is a last important adjustment we have to make to the path: currently, the z-position of the path coincides with the zposition of the floor. The consequence is that sometimes we see the path, sometimes the floor (this effect is known as z-fighting in the openGl jargon). This not only affects what we see, but also what the vision sensors see. In order to avoid problems linked to z-fighting, just move the position of the path object up by 0.5 mm.</span> <br/> <br/>一旦對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改），請選擇它，<br/>然後在路徑屬性中取消“Show orientation of points 顯示點的方向”，“Show path line<br/>顯示路徑線”和“Show current position on path in the path properties 顯示路徑上的當<br/>前位置”。然後單擊顯示路徑外型的對話框。這將打開路徑外型對話框。單擊啟用路<br/>徑外型，將類型設置為水平線段，並將縮放因子設置為 4.0。最後將顏色調整為黑<br/>色。我們必須對路徑進行最後一個重要的調整：當前，路徑的 z 位置與地板的 z 位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在 openGl 中被稱為“z-fighting”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與 z-fighting 有關的問題，只需將路徑對象的位置向上移動 0.5 毫米</p>
<p><span style="color: #ff0000;">The last step is to adjust the controller of BubbleRob, so that it will also follow the black path. Open the child script attached to bubbleRob, and replace it with following code</span>: <br/> <br/>最後一步是調整 BubbleRob 的控制器，使其也將遵循黑色路徑。打開附加到<br/>bubbleRob 的子腳本，並將其替換為以下代碼：</p>
<pre class="lightRedBox">function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100
end

function sysCall_init()
    -- This is executed exactly once, the first time this script is executed
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)
    leftMotor=sim.getObjectHandle("leftMotor")
    rightMotor=sim.getObjectHandle("rightMotor")
    noseSensor=sim.getObjectHandle("sensingNose")
    minMaxSpeed={50*math.pi/180,300*math.pi/180}
    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode
    floorSensorHandles={-1,-1,-1}
    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")
    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")
    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")
    -- Create the custom UI:
        xml = '&lt;ui title="'..sim.getObjectName(bubbleRobBase)..' speed" closeable="false" resizeable="false" activate="false"&gt;'..[[
        &lt;hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/&gt;
        &lt;label text="" style="* {margin-left: 300px;}"/&gt;
        &lt;/ui&gt;
        ]]
    ui=simUI.reate(xml)
    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5
    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))
end

function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor)
    if (result&gt;0) then backUntilTime=sim.getSimulationTime()+4 end

    -- read the line detection sensors:
    sensorReading={false,false,false}
    for i=1,3,1 do
        result,data=sim.readVisionSensor(floorSensorHandles[i])
        if (result&gt;=0) then
            sensorReading[i]=(data[11]&lt;0.3) -- data[11] is the average of intensity of the image
        end
        print(sensorReading[i])
    end

    -- compute left and right velocities to follow the detected line:
    rightV=speed
    leftV=speed
    if sensorReading[1] then
        leftV=0.03*speed
    end
    if sensorReading[3] then
        rightV=0.03*speed
    end
    if sensorReading[1] and sensorReading[3] then
        backUntilTime=sim.getSimulationTime()+2
    end

    if (backUntilTime&lt;sim.getSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        sim.setJointTargetVelocity(leftMotor,leftV)
        sim.setJointTargetVelocity(rightMotor,rightV)
    else
        -- When in backward mode, we simply backup in a curve at reduced speed
        sim.setJointTargetVelocity(leftMotor,-speed/2)
        sim.setJointTargetVelocity(rightMotor,-speed/8)
    end
end

function sysCall_cleanup()
	simUI.destroy(ui)
end</pre>
<p><span style="color: #ff0000;">You can easily debug your line following vision sensors: select one, then in the scene view select [Right-click --&gt; Add --&gt; Floating view], then in the newly added floating view select [Right click --&gt; View --&gt; Associate view with selected vision sensor].</span> <br/> <br/>您可以輕鬆地調試以下視覺傳感器的線：選擇一個，然後在場景視圖中選擇[右鍵-&gt;添加-&gt;浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵-&gt;視圖- -&gt;將視圖與選定的視覺傳感器關聯]。 <br/> <br/><span style="color: #ff0000;">Finally, remove the auxiliary items that were added in the first BubbleRob tutorial: remove the image processing vision sensor, its associated floating view, the floating view representing the obstacle clearance. Remove also the distance calculation object via the distance dialog. That's it!</span> <br/> <br/>最後，刪除在第一個 BubbleRob 教程中添加的輔助項：刪除圖像處理視覺傳感器，其關聯的浮動視圖，該浮動視圖表示障礙物的清除。通過距離對話框也刪除距離計算對象。</p>
<h2>simulation</h2>
<p><span style="color: #0000ff;">由40723221提供</span></p>
<p><span style="color: #ff0000;"><strong>Simulation</strong></span></p>
<p><strong>模擬</strong></p>
<p><span style="color: #ff0000;">A simulation in CoppeliaSim can be started, paused and stopped with [Menu bar --&gt; Simulation --&gt; Start/Pause/Stop simulation] or through the related toolbar buttons:</span></p>
<p>可以使用<span>[</span>菜單欄<span>-&gt;</span>模擬<span>-&gt;</span>開始<span>/</span>暫停<span>/</span>停止模擬<span>]</span>或通過相關的工具欄按鈕來啟動，暫停和停止<span>CoppeliaSim</span>中的模擬：</p>
<p><img alt="" height="37" src="/images/0.png" width="124"/></p>
<p><span style="color: #ff0000;">[Simulation start/pause/stop toolbar buttons]</span></p>
<p><span>[</span>模擬開始<span>/</span>暫停<span>/</span>停止工具欄按鈕<span>]</span></p>
<p><span style="color: #ff0000;">Internally, the simulator will use additional intermediate states in order to correctly inform scripts or programs about what will happen next. Following state diagram illustrates the simulator's internal states:</span></p>
<p>在模擬內，模擬器將使用其他中間狀態，以正確告知腳本或程序接下來將發生的情況。以下狀態圖說明了模擬器的內部狀態：</p>
<p><span style="color: #ff0000;">[Simulation state diagram]</span></p>
<p><span>[</span>模擬狀態圖<span>]</span></p>
<p><span><img alt="" height="489" src="https://s40723221.github.io/cd2020/images/simulation%20state%20diagram.png" width="640"/></span></p>
<p><span style="color: #ff0000;">Scripts and programs should alwaysreact according to the current system call function and possibly the simulation state in order to behave correctly. It is good practice to divide each control code into at least 4 system call functions (e.g. for non-threaded child scripts):</span></p>
<p>腳本和程序應始終根據當前系統調用功能以及可能的模擬狀態進行反應，以便正確運行。優良作法是將每個控制代碼至少分為<span>4</span>個系統調用函數（例如，用於非線程子腳本）：</p>
<p><span style="color: #ff0000;">1.Initialization function: sysCall_init: the function is called only when the script is initialized.</span></p>
<p><span style="color: #ff0000;">2.Actuation function: sysCall_actuation: the function is called when actuation should happen.</span></p>
<p><span style="color: #ff0000;">3.Sensing function: sysCall_sensing: this function is called when sensing should happen.</span></p>
<p><span style="color: #ff0000;">4.Clean-up function: sysCall_cleanup: the function is called just before the script is de-initialized (e.g. at simulation end, or when the script is destroyed)</span></p>
<p><span>1.Initialization</span><span>函數：</span><span>sysCall_init</span><span>：僅在腳本初始化時調用該函數。</span></p>
<p><span>2.actuation</span>函數：<span>sysCall_actuation</span>：應在發生<span>actuation</span>時調用該函數。</p>
<p><span>3.Sensing</span>函數：<span>sysCall_sensing</span>：當應該進行檢測時調用此函數。</p>
<p><span>4.Clean-up</span>函數：<span>sysCall_cleanup</span>：該函數在腳本未初始化之前被調用（例如在模擬結束時或腳本被銷毀時）</p>
<p><span style="color: #ff0000;">For examples on how to arrange a typical script, refer to the main script, the child scripts and customization scripts pages.</span></p>
<p>有關如何安排典型腳本的示例，請參閱主腳本，子腳本和自定義腳本頁面。</p>
<p><span style="color: #ff0000;">The simulator operates by advancing the simulation time at constant time steps. Following figure illustrates the main simulation loop</span></p>
<p>模擬器通過以恆定的時間步長推進模擬時間來進行操作。下圖說明了主要的模擬循環</p>
<p><span style="color: #ff0000;">Simulation loop</span></p>
<p><span><img alt="" height="196" src="https://s40723221.github.io/cd2020/images/simulation%20loop.png" width="450"/></span></p>
<p><span style="color: #ff0000;">[Main simulation loop]</span></p>
<p><span>[</span>主要模擬路徑參考圖<span>]</span></p>
<p><span style="color: #ff0000;">Real-time simulation is supported by trying to keep the simulation time synchronized with the real time:</span></p>
<p>通過嘗試使模擬時間與實時保持同步來支持實時模擬：</p>
<p><img alt="" height="293" src="https://s40723221.github.io/cd2020/images/main%20simulation%20loop.png" width="450"/></p>
<p><span style="color: #ff0000;">[Real-time simulation loop]</span></p>
<p><span>[</span>加入真實時間後的模擬參考圖<span>]</span></p>
<p><span style="color: #ff0000;">Following represents a very simplified main client application (messaging, plugin handling and other details have been omitted for clarity purpose):</span></p>
<p>以下是一個非常簡單的主客戶端應用程序（為清晰起見，已省略了消息，插件處理和其他詳細信息）：</p>
<p>void initializationCallback<br/>{<br/>    // do some initialization here</p>
<p>}</p>
<p> </p>
<p>void loopCallback<br/>{<br/>    if ( (simGetSimulationState()&amp;sim_simulation_advancing)!=0 )<br/>    {<br/>        if ( (simGetRealTimeSimulation()!=1)||(simIsRealTimeSimulationStepNeeded()==1) )<br/>        {<br/>            if ((simHandleMainScript()&amp;sim_script_main_script_not_called)==0)<br/>                simAdvanceSimulationByOneStep();<br/>        }<br/>    }<br/>}</p>
<p> </p>
<p>void deinitializationCallback<br/>{<br/>    // do some clean-up here</p>
<p>}</p>
<p><span style="color: #ff0000;">Depending on the simulation complexity, performance of the computer and simulation settings, real-time simulation might not always be possible.</span></p>
<p>取決於模擬的複雜性，電腦的性能和模擬設置，實時模擬的時候並不總是完美的。</p>
<p><span style="color: #ff0000;">In non real-time simulations, the simulation speed (i.e. the perceived speed) is mainly dependent on two factors: the simulation time step and the number of simulation passes for one rendering pass (see the simulation dialog for more details). In the case of a real-time simulation, the simulation speed mainly depends on the real-time multiplication coefficient, but also to a certain degree of the simulation time step (a too small simulation time step might not be compatible with the real-time character of a simulation because of the limited calculation power of the computer). During simulation, the simulation speed can be adjusted with following toolbar buttons</span></p>
<p>在非實時模擬中，模擬速度（即感知速度）主要取決於兩個因素：模擬時間步長和一個渲染通道的模擬通道數量（有關更多詳細信息，請參見模擬對話框）。在實時模擬的情況下，模擬速度主要取決於實時乘法係數，而且在一定程度上取決於模擬時間步長（太小的模擬時間步長可能與實時時間不兼容）。由於計算機的計算能力有限，因此無法進行模擬。在模擬過程中，可以通過以下工具欄按鈕來調節模擬速度</p>
<p><span style="color: #ff0000;">Simulation speed</span></p>
<p><span><img alt="" height="37" src="https://s40723221.github.io/cd2020/images/simulation%20speed.png" width="81"/></span></p>
<p><span style="color: #ff0000;">[Simulation speed adjustment toolbar buttons]</span></p>
<p><span style="color: #ff0000;">The simulation speed is adjusted in a way so that the initial simulation time step is never increased (because this might have as consequence the breaking of a mechanism for example). Following two figures illustrate the simulation speed adjustment mechanisms</span></p>
<p>以某種方式調整模擬速度，以使初始模擬時間的步長永遠不會增加（這可能因此而導致機制中斷）。下兩個圖說明了模擬速度調節機制</p>
<p><img alt="" height="173" src="https://s40723221.github.io/cd2020/images/i1.png" width="600"/></p>
<p><span style="color: #ff0000;">[Simulation speed adjustment mechanism for non real-time simulations]</span><br/>[非實時模擬的模擬速度調整機制]</p>
<p><img alt="" height="180" src="https://s40723221.github.io/cd2020/images/i2.png" width="600"/></p>
<p><span style="color: #ff0000;">[Simulation speed adjustment mechanism for real-time simulations]</span></p>
<p>[實時模擬與調整機制]</p>
<p><span style="color: #ff0000;">By default, each simulation cycle is composed by following sequential operations:</span></p>
<p><span style="color: #ff0000;">1.Executing the main script</span></p>
<p><span style="color: #ff0000;">2.Rendering the scen</span></p>
<p>默認情況下，每個模擬週期由以下順序操作組成：</p>
<p><span>1.</span>執行主腳本</p>
<p><span>2.</span>渲染場景</p>
<p><span style="color: #ff0000;">Threaded rendering</span></p>
<p><span style="color: #ff0000;">The rendering operation will always increase the simulation cycle duration, thus also slowing down simulation speed. The number of main script executions per scene rendering can be defined (see further up), but this is not enough in some situations, because rendering will still slow down every xth simulation cycle (which can be handicapping with real-time requirements). For those situations, a threaded rendering mode can be activated via the user settings, or via the following toolbar button:</span><br/><span style="color: #ff0000;">When the threaded rendering mode is activated, a simulation cycle will only consist in execution of the main script, thus simulations will run at maximum speed. Rendering will happen via a different thread, and not slow down the simulation task. The drawbacks have however to be considered. When threaded rendering is activated, then:</span></p>
<p><img alt="" height="34" src="https://s40723221.github.io/cd2020/images/fire.png" width="35"/><br/><span style="color: #ff0000;"> [Threaded rendering toolbar button]</span></p>
<p><span style="color: #ff0000;">Rendering will happen asynchronously to the simulation loop, and visual glitches might appear</span></p>
<p><span style="color: #ff0000;">The video recorder will not operate at constant speed (some frames might get skipped)</span></p>
<p><span style="color: #ff0000;">The stability of the application might be reduced</span></p>
<p><span style="color: #ff0000;">Some operations (e.g. erasing an object, etc.) require to wait for the rendering thread to finish work, before being able to execute, and vice-versa. In those situations, cycles could take more time than in the sequential rendering mode</span></p>
<p>交互渲染</p>
<p>渲染操作將始終增加模擬週期的持續時間，從而也降低了模擬速度。可以定義每個場景渲染的主腳本執行次數（請參閱後面的內容），但這在某些情況下還不夠，因為渲染仍然會減慢每個第<span>x</span>個模擬週期的時間（這可能會限制實時性）。在這種情況下，可以通過用戶設置或以下工具欄按鈕激活線程渲染模式：</p>
<p><span> [</span>線程渲染工具欄按鈕<span>]</span></p>
<p>激活線程渲染模式後，模擬週期將僅包含在執行主腳本中，因此模擬將以最大速度運行。渲染將通過不同的線程進行，並且不會減慢模擬任務的速度。然而，必須考慮缺點。激活線程渲染後，：</p>
<p>渲染將與模擬循環不會同步進行，並且可能會出現視覺上的瑕疵</p>
<p>錄影機將無法以恆定速度運行（可能會跳過某些幀數）</p>
<p>應用程序的穩定性可能會降低</p>
<p>某些操作（例如去除物件等）需要等待渲染得線程完成工作才能執行，反之亦然。在那些情況下，循環可能比有順序的渲染模式花費更多的時間。</p>
<p><span style="color: #ff0000;"><strong>Simulation dialog</strong></span></p>
<p><strong>模擬控制視窗</strong></p>
<p><span style="color: #ff0000;">The simulation dialog can be accessed with [Menu bar --&gt; Simulation --&gt; Simulation settings] or by clicking following toolbar button:</span></p>
<p>可以通過<span>[</span>菜單欄<span>-&gt;</span>模擬<span>-&gt;</span>模擬設置<span>]</span>或單擊以下工具欄按鈕來訪問模擬對話框：</p>
<p><img alt="" height="37" src="https://s40723221.github.io/cd2020/images/tool1.png" width="38"/></p>
<p><span style="color: #ff0000;">[Simulation toolbar button]</span></p>
<p><span>[</span>模擬工具欄按鈕<span>]</span></p>
<p><span><img alt="" height="353" src="https://s40723221.github.io/cd2020/images/toolbar.png" width="396"/></span></p>
<p><span style="color: #ff0000;">[Simulation settings dialog]</span></p>
<p>模擬設定視窗</p>
<p><span style="color: #ff0000;">Time step: the simulation time step. Each time the main script was executed, the simulation time is incremented by the simulation time step. Using large time steps results in fast but inaccurate/unstable simulations. Small time steps on the other hand will (generally) lead to more precise simulations, but will take more time. It is highly recommended to keep a default time step.</span></p>
<p><span style="color: #ff0000;">Simulation passes per frame (ppf): the number of simulation passes for one rendering pass. A value of 10 would mean that the main script is executed 10 times (10 simulation steps) before the screen is refreshed. If you have a slow graphic card, you can choose to display only one frame out of two for instance.</span></p>
<p><span style="color: #ff0000;">Pause when simulation time higher than: allows specifying a simulation time at which the simulation will be paused (e.g. to be able to analyze some results at a specific simulation time).</span></p>
<p><span><span style="color: #ff0000;">Pause on script</span> error: if enabled, then a simulation will be paused when a script error occurs.</span></p>
<p>時間步長：模擬時間步長。每次執行主腳本時，模擬時間都會增加模擬時間的步長。使用較大的時間步長會導致快速但不准確<span>/</span>不穩定的模擬。另一方面，較小的時間步長（通常）會有更精確的模擬，但是會花費更多時間。強烈建議保留默認的時間步長。</p>
<p>每幀模擬次數（<span>ppf</span>）：一個渲染遍的模擬次數。其值為<span>10</span>表示刷新屏幕之前，主腳本已執行<span>10</span>次（<span>10</span>個模擬步驟）。如果您的顯示卡較慢，則可以選擇僅顯示兩幅中的一幅。</p>
<p>當模擬時間高於以下時間時則會暫停：允許指定暫停模擬的模擬時間（例如，能夠在特定模擬時間分析某些結果）。</p>
<p>腳本錯誤暫停：如果啟用，則在腳本錯誤發生時暫停模擬。</p>
<p><span style="color: #ff0000;">Full screen at simulation start: if enabled, then simulation starts in full screen mode. Be aware that in full screen mode, dialogs and messages won't appear or won't be visible, and only the left mouse button will be active. For that reason that mode is only recommended once a scene is properly configured and final. Full screen mode can be left with the esc-key, and toggled via the boolean parameter sim_booparam_fullscreen during simulation. Unler Linux and MacOS the full-screen mode might only partially be supported, and switching back to normal mode might fail on certain systems.</span></p>
<p>模擬開始時全屏：如果啟用，則模擬以全屏模式開始。請注意，在全屏模式下，設置視窗和消息將不會出現或不可見，只有鼠標左鍵處於活動狀態時才會出現。因此，僅在正確配置場景並最終確定場景後才建議使用該模式。可以使用<span>esc</span>鍵保留全屏模式，並在模擬過程中通過布爾參數<span>sim_booparam_fullscreen</span>進行切換。<span><span> </span>Unler Linux</span>和<span>MacOS</span>可能僅部分支持全屏模式，並且在某些系統上切換回普通模式可能會失敗。</p>
<p><span style="color: #ff0000;">Real-time simulation, multiplication factor: if selected, then the simulation time will try to follow the real-time. A multiplication factor of X would try to run a simulation X times faster than real-time.</span></p>
<p>實際時間的模擬，倍增係數：如果選擇，則模擬時間將嘗試跟隨實際時間。<span><span> </span>X</span>的乘數將使模擬運行比實時快<span>X</span>倍。</p>
<p><span style="color: #ff0000;">Try catching up when behind: during real-time simulation, it can happen that the simulation time is not able to follow the real-time (e.g. because of some momentarily heavy calculations). In that case, if this check-box is selected, then the simulation time will try catching up the lost time (e.g. when the calculation load is again reduced), which results in an apparent speed-up.</span></p>
<p>在落後時嘗試趕上：在實時模擬過程中，模擬時間可能無法實時跟踪（例如，由於某些瞬間繁重的計算）。在這種情況下，如果選中此複選框，則模擬時間將嘗試趕上不足的時間（例如，當計算負載再次減少時），從而明顯加快速度。</p>
<p><span style="color: #ff0000;">Reset scene to initial state: when selected, then all objects will be reset to their initial state: this includes the object local position, local orientation and its parent (as long as the object wasn't modified otherwise (e.g. scaled)), joint and path intrinsic positions, floating view positions and sizes, etc. This means that the next simulation run will execute in a same way as previous one, unless heavy changes were undertaken (shape scaling, object removal, etc.). Some minor settings are ignored by this item.</span></p>
<p>將場景重置為初始狀態：選中後，所有物件都將重置為其初始狀態：包括對象的局部位置，局部方向及其父對象（只要未進行其他修改（例如，縮放），以及路徑的固有位置，浮動視圖的位置和大小等。這意味著除非進行了重大更改（形狀縮放，對象移除等），否則下一次模擬運行將以與上一次相同的方式執行。此項目將忽略一些次要設置。</p>
<p><span style="color: #ff0000;">Remove new objects: when selected, then scene objects added during a simulation run will be removed at the end of the simulation.</span></p>
<p>刪除新對象：選中後，在模擬運行期間添加的場景對象將在模擬結束時被刪除。</p>
<h1>assignments</h1>
<h2>assignment1</h2>
<p><a href="https://github.com/s40723221/cd2020/blob/master/downloads/Collaborative%20product%20design%20processes%20of%20industrial%20design%20and%20engineering%20design%20in%20consumer%20product%20companies%E7%BF%BB%E8%AD%AF.pdf">Collaborative product design processes of industrial design and engineering design in consumer product companies</a></p>
<p>1. Describe how to do an efficient random grouping for this course or do the roll calling randomly?</p>
<p>2. Describe how to prepare a portable Python programming system for Windows 10 64bit system to allow one the maintain<span> </span><a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a><span> </span>website,<span> </span><a href="https://github.com/getpelican/pelican">Pelican blog</a><span> </span>and<span> </span><a href="https://github.com/hakimel/reveal.js/">Reveal.js</a><span> </span>presentation on<span> </span><a href="https://github.com/">Github</a>?</p>
<p>3. What do you need to know from <a href="http://www.coppeliarobotics.com/helpFiles/index.html">http://www.coppeliarobotics.com/helpFiles/index.html</a> to implement a four-wheeled robot?</p>
<h3>Random grouping</h3>
<p><span lang="en"><span style="color: #3366ff;">資料提供及統整:40723221</span> </span></p>
<p><span lang="en">1.如何從網站中抓取所需之資料(如名單)?</span></p>
<p><span lang="en">2.順利抓取名單後如何運用於程式中並使其能夠正確的讀取?</span></p>
<p><span lang="en">3.如何在上述皆達成後順利達到分組的效果?<br/><br/>我們必須要了解 import 的 request、ast、random 是甚麼模組。</span></p>
<p><span lang="en">(1) Request 為能夠下載網頁的一項 python 中的模組，我們能夠使用 request.get(加入網址)的方式來達到擷取網頁資料的目的。</span></p>
<p><span lang="en"><span>參考連結</span>:<span> </span><a href="https://blog.gtwang.org/programming/python-requests-module-tutorial/">https://blog.gtwang.org/programming/python-requests-module-tutorial/</a><br/>(2) ast 中的 literal_eval 可以將剛剛擷取下來的網頁資料(僅允許為字符串，字<br/>節對象(bytes)，數值，元組，列表，字典，集合，布爾值和 None)才可以進<br/>行轉換。<br/></span></p>
<p><span lang="en"><span>參考連結</span>:<span> </span><a href="https://docs.python.org/zh-cn/3/library/ast.html">https://docs.python.org/zh-cn/3/library/ast.html</a></span></p>
<p><span lang="en">(3) random 中有許多不同的用法，在每周抽點中我們使用的是 shuffle 的用法， 此 用法會將給定的元素隨機打亂，以達到亂數的目的。</span></p>
<p><span lang="en"><span>參考連結</span>:<span> </span><a href="https://ithelp.ithome.com.tw/articles/10207483">https://ithelp.ithome.com.tw/articles/10207483</a></span></p>
<p><span lang="en">最後我們可以經由 for 迴圈對剛剛打亂的元素進行我們所想要的分法已達到 亂數分組中的分組的目的。<br/><br/><span>亂數分組及每周抽點程式比較</span>:亂數分組必須要從 index.html 中去抓取網址， 如在 html 中不存在網址才會從主程式 evenGrouping.dart 中抓取網址，而每 周抽點的程式中則是採用 Request 的方式去產生擷取網站資料的目的，在亂 數分組中可以以 dart 的方式去 run 就會達到分組的目的，也可以使用 scite 進 行 python 指令的運行，這樣也可以對每周抽點進行抽點運行。</span></p>
<h3>Portable system</h3>
<p><span style="color: #3366ff;">資料提供及資料統整:40723221、40723237、 40723249 、40723244 </span></p>
<p><span lang="en">問題:如何對現有的可攜進行更新 python 至 3.8.2 的動作，可攜系統的完整安裝流程，及 python3.8.2 的運行需要做哪一些更動?<br/><br/><span>(1)直接對舊有可攜進行更新<span> </span></span></span><span lang="en"><span>將可攜系統下的 python 3.7.3 系統更新至 python 3.8.2</span><br/></span></p>
<p><span lang="en">1.進入 <a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a><br/>2.往下滑到最底，下載 Windows x86-64 executable installer(上下兩者分別為 Windows x86-64 embeddable zip file 和 Windows x86-64 web-based installer 這兩者是嵌入式64位元python的可執行壓縮檔案和64位元網際端的可執行檔 案)在本次可攜的更新中不會使用到<br/>3.接著開始下載切記不要勾選 pip 選項，接著按下 next<br/>4.先將下載下來的python3.8.2放置桌面，並且將y槽下的data新增加一個py382 的資料夾方便之後可以做測試是否 3.8.2 之 python 可以正常的運行<br/>5.將剛剛下載之 python3.8.2 放置於剛剛創建的 py382 中切記不要將原先的 py373刪除，若之後 py382 的執行產生錯誤才可以使用 py373 做返回原版本的 動作<br/>6.更改執行檔 start_mdecourse.bat 將底下 py373 處更改為自己下在 python3.8.2 所儲存的資料夾名稱<br/></span></p>
<p><span lang="en"><img alt="" height="746" src="https://s40723221.github.io/cd2020/images/LEO%E5%95%8F%E9%A1%8C.PNG" width="1061"/><br/>[start 開啟檔的修改]</span></p>
<p><span lang="en">7.重新啟動剛剛更新的執行檔<br/>8.執行 python get-pip.py<br/>9..執行 python -m pip install flask flask-cors markdown lxml bs4 pelican leo<br/><span style="color: #ff0000;">影片教學網址 :</span><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/ft4s-DvMk_M" width="560"></iframe><br/><br/><span>(2)從頭對創建 python3.8.2 的可攜</span></span></p>
<p><span lang="en">1.往下滑到最底，下載 Windows x86-64 executable installer</span></p>
<p><span lang="en">2.SciTE：到 https://www.scintilla.org/SciTEDownload.html，下載 ” full 64-bit download” 把檔案 ”wscite432” 搬移至 data 目錄底下，在到data下的wscite432 下的 wscite 目錄下執行”scite.exe”，且<span>打開 Options 下的 Global Options File 其中的預設值 code.page=0 修改設定為 code.page=65001，將 load.on.activate=1 前面的井字號拿掉</span></span></p>
<p><span lang="en">3. MSYS2：https://www.msys2.org/ 下載 msys2-x86_64-20190524.exe 並執行</span></p>
<p><span lang="en">4. PortableGit：https://git-scm.com/download/win 下載 64-bit Git for Windows Portable 安裝在 data 目錄下</span></p>
<p><span lang="en">5.安裝pip為以更新的方式更新可攜或者是以從頭開始的方式更新可攜都必須要 安裝指令為 python get-pip.py</span></p>
<p><span lang="en"> 6. 指令為 pip install flask bs4 lxml pelican markdown flask_cors 也必須要安裝這些模組</span></p>
<p><span lang="en">7.</span>home<span>：</span>把舊的 2019fall/data/home 裡面複製 .gitconfig 並貼到新的 home 裡</p>
<p><span lang="en">8.</span>tcc<span>：</span>到 <a href="https://github.com/TinyCC/tinycc">https://github.com/TinyCC/tinycc</a> 接著到命令提示字元裡 git clone <a href="https://github.com/TinyCC/tinycc.git">https://github.com/TinyCC/tinycc.git</a> tcc</p>
<p><span lang="en">9.</span>Jupyterlab<span>：</span><span>到命令提示字元裡使用 pip install jupyterlab==2.0.1 就會自動安裝進去</span></p>
<p><span lang="en">10.</span>Fossil SCM<span>：</span>到 <a href="https://www.fossil-scm.org/home/doc/trunk/www/index.wiki">https://www.fossil-scm.org/home/doc/trunk/www/index.wiki</a> 下載 fossil scm <span>下載完後，解壓縮檔案到 CD2020/data</span></p>
<p><span>11.</span>Flutter<span>：</span>到 <a href="https://github.com/flutter/flutter">https://github.com/flutter/flutter</a> <span>接著到命令提示字元裡 git clone https://github.com/flutter/flutter.git -b stable</span></p>
<p><span>12.</span><span>vscode：</span><span>到 <a href="https://github.com/microsoft/vscode">https://github.com/microsoft/vscode</a> 接著到命令提示字元裡 git clone https://github.com/microsoft/vscode.git  vscode</span></p>
<p><span>13.</span>tmp<span>：</span>git clone 自己的倉儲</p>
<p><span>影片教學網址 :</span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/HuHDDvwnMag" width="560"></iframe></p>
<p><span lang="en"><br/><br/>兩者的比較差異:更新舊有的可攜需要的主要為 python get-pip.py 與下載模 組 pip install flask bs4 lxml pelican markdown flask_cors 並且對 開啟檔 start_mdecourse.bat 進行內容的更動及可，從頭開始執行可攜的更新則 比較麻煩需要下載的模組較多，必須對 SciTE、MSYS2、PortableGit、Tiny C Compiler、Jupyterlab、Fossil SCM 有需要甚至可以將 webots、v-rep 及其他如sharex 等軟體載入可攜系統中。</span></p>
<h3>four wheel car</h3>
<p><span style="color: #3366ff;">本資料由40723222提供</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm"><strong>BubbleRob tutorial</strong></a><strong>:</strong>在此教程中可以透過我們自行設置的BubbleRob機器人進行初步的模擬，在上學期中我們有實際的以v-rep操作過這個教程，在這個教程中有含括了很多包括如何建造模型(機器人本體、輪子、後方支撐滑塊、障礙物)，並且經由設定好的距離傳感器去感知並且避開我們所設立的障礙物，其中很重要的要點是如何去設計指令使輪胎兩側的傳動器依照我們所想要的方式去做運動，且當距離感測器接近我們所設立的障礙物時，他必須要做出相對應的反應部會使其碰到障礙物，另外還必須要考慮到視覺辨識系統，使機器人在移動時我們能夠觀測到機器人前方之狀況，此教程能夠使我們更加有效率的使用v-rep這套模擬軟體。</p>
<p>影片教學網址:<span><span> </span><a href="https://www.youtube.com/watch?v=CXGJmwHt81g&amp;t=59s">https://www.youtube.com/watch?v=CXGJmwHt81g&amp;t=59s</a></span></p>
<p><span style="color: #3366ff;">本資料由40723243</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm"><strong>Line following BubbleRob tutorial</strong></a><strong>:</strong>在此模擬教程中我們銜接上面的BubbleRob教程，我們想要使其能夠按照我們所規劃的路徑移動，在四輪車的方面這樣的功能能夠使我們有效的規劃四輪車的行走路徑，以達到更好去控制四輪的目的，在無外部控制器或者是想要直接在模擬器的環境中直接模擬可以採用該方法達到比較好的效率。</p>
<p><span style="color: #3366ff;">本資料由40723240提供</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm"><strong>External controller tutorial</strong></a><strong>:</strong>遠端控制器教程中，當我們想要從遠端電腦的方式控制我們在模擬中的物件例如:四輪車或機器人時我們就會需要一項遠程控制的控制器，我們可以參考<a href="https://www.coppeliarobotics.com/helpFiles/en/ros1Tutorial.htm">ROS tutorial</a>及<a href="https://www.coppeliarobotics.com/helpFiles/en/ros2Tutorial.htm">ROS 2 tutorial</a>來達到我們想做控制的想法，<span>ROS</span>主要比較像是對於機器人的中間控制系統，他能夠藉由傳感器來指引機器人該往哪個方向移動，如下圖所示，就是<span>ROS</span>較好的解釋。</p>
<p>ROS:比較像是在負責為機器人的各個元件進行溝通與操作的一個框架，以機器人的行走為例，要讓機器人走路需要控制其底下的馬達、還有一些感測器以進行避開障礙物的功能等等，ROS內就有這種類型的函式可以讓控制馬達的程式得以與接收感測器的程式溝通。</p>
<p><img alt="" height="194" src="https://s40723221.github.io/cd2020/images/ros.png" width="434"/></p>
<p><span style="color: #3366ff;">本資料由40723221提供</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/simulation.htm"><strong>Simulation</strong></a><strong>:</strong>這裡主要是在描述模擬是如何建立的，在模擬中我們雖然比較不會受到的限制很少，但是因為硬體的關係我們必須要適度調整好例如:模擬的速度快慢、非主要物件的加入或移除，我們也可以從這裡看到系統是如何調整速度運行的快慢和機制。</p>
<p><span style="color: #3366ff;">本資料由40723221提供</span></p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm"><strong>Simulation settings dialog</strong></a><strong>:</strong></p>
<p>這篇教程主要在幫助我們理解如何設定模擬時所需要設定的視窗要如何操控，並且講解當我們導入實際的時間運行時，模擬會產生怎樣的變化，但當我們使用加速或減慢時模擬的變化又會怎樣，在一般的情況下模擬的時間步長如果太快會造成模擬的結果及過程不精確甚至會有偵數漏掉的問題，如果太慢雖然會有較精確的結果和過程但會使得模擬時的總時長太久，在某些結構較符雜的模擬之下，模擬在運行到較為複雜的動作或者較難去運算的動作時會使得模擬的時間跟不上實際的時間，這時v-rep內建有寫入能夠補正此bug的方式，他可以藉由進行其他較為簡單的運動模擬時加速已達到與原先時長同步的效果。</p>
<p><span>總結</span>:完成四輪車的模擬必須要有對於模擬軟體的熟悉、馬達的設立、外部控制器的連結、模型的組立、結構的評估(過於複雜的結構可以經由省略內部某些部份零件或者是外觀零件的方式達到簡化)、內部攝像頭的設立、如何以程式(如:python)去所存於模擬中的物件並且對外部控制器做連結，若要進行只單單在模擬軟體中的模擬而不依靠外部控制器去控制作動，則必須要設定在內部模擬器中的感測器(如:距離感射器、視覺感測器等等……)並且布置如線條或者是障礙物的方式去使感測器運行，使物件達到想要的避讓或者是作動，而要達到這些都必須通過程式的設置來完成。</p>
<p><span>ast</span>模組<span>:<a href="https://docs.python.org/zh-cn/3/library/ast.html">https://docs.python.org/zh-cn/3/library/ast.html</a></span></p>
<p><span>Rendom</span>模組<span>:<a href="https://ithelp.ithome.com.tw/articles/10207483">https://ithelp.ithome.com.tw/articles/10207483</a></span></p>
<p><span>Request:<a href="https://blog.gtwang.org/programming/python-requests-module-tutorial/">https://blog.gtwang.org/programming/python-requests-module-tutorial/</a></span></p>
<p><span>mde.tw</span>中分組之程式<span>:<a href="http://mde.tw/cd2020/content/Grouping.html">http://mde.tw/cd2020/content/Grouping.html</a></span></p>
<p>v-rep使用手冊: <span><a href="http://www.coppeliarobotics.com/helpFiles/index.html">http://www.coppeliarobotics.com/helpFiles/index.html</a></span> </p>
<h2>assignment2</h2>
<h3>Product design process</h3>
<p><span><strong>Collaborative product design processes of industrial design and engineering design in consumer product companies</strong></span></p>
<p><strong>產品公司中的工業設計和工程設計的協作產品設計過程</strong></p>
<p><span>This study aims to elucidate how industrial designers and engineering designers collaborate, and how such an alliance reflects in the design process. We conducted in-depth interviews about actual product design projects with 34 industrial and engineering designers from six consumer product manufacturers. We firstly identified individual design processes from the interview data. Secondly, we then compared and merged the design processes into collaborative processes using a mosaic method. We finally simplified the collaborative processes to create representative process models. As a result, we discovered four types of typical collaborative product design processes and their characteristics e Type 1: ID-led Concept-driven Process, Type 2: ID-led Combined Outside-inside Process, Type 3: ED-led Inside-first Process, and Type 4: ID&amp;ED Synergetic Process. </span></p>
<p>這項研究在闡明工業設計師和工程設計師如何協作，以及這種合作如何體現在設計過程中。我們與來自六個產品製造商的34名工業和工程設計師進行了有關實際產品設計項目的深入採訪。我們首先從訪問數據中識別出各個設計過程。其次，我們使用鑲嵌的方法將設計過程進行比較並合併為協作過程。最後，我們簡化了協作流程，以創建具有代表性的流程模型。結果，我們發現了四種類型的典型協同產品設計流程及其特徵：e類型1：由ID主導的概念驅動過程，類型2：由ID主導的內外聯合過程，類型3：由ED主導的由內到外的流程，類型4：ID＆ED協同流程。</p>
<p><span>Integrated contribution of engineering design and industrial design is essential to launch successful products to the market. Product design can hardly be explained from a mono disciplinary perspective. However, it is known that engineering design and industrial design have considerably different design practices (Pei, 2009; Persson &amp; Wickman, 2004), and their design approaches are in some ways opposite to each other (Eder, 2013; Hosnedl, Srp, &amp; Dvorak, 2008; Pahl, Wallace, &amp; Blessing, 2007). The indus- trial designers’ role includes enhancing user experience of a product and developing its outside form and interface (Ulrich &amp; Eppinger, 2012). They employ knowledge and skills in aesthetics and ergonomics (Eder, 2013; Pahl et al., 2007). Under the interaction with industrial designers, engineering designers take part in implementing the design concept developed by indus- trial designers (Persson &amp; Warell, 2003). Engineering designers provide a means for the product to be functioning, reliable, and manufactured (Hubka &amp; Eder, 2012; Pahl et al., 2007). This leads to different approaches between industrial and engineering designers (Cross, 2008; Hubka &amp; Eder, 2012). </span></p>
<p>工程設計和工業設計的綜合貢獻對於向市場推出成功的產品至關重要。從單學科的角度很難解釋產品設計。但是，眾所周知，工程設計和工業設計在設計實踐上有很大不同(Pei, 2009; Persson &amp; Wickman, 2004)，並且它們的設計方法在某些方面是相衝突的(Eder, 2013; Hosnedl, Srp, &amp; Dvorak, 2008; Pahl, Wallace, &amp; Blessing, 2007)。工業設計師的角色包括增強產品的用戶體驗並開發其外部樣式和界面(Ulrich &amp; Eppinger, 2012)。他們運用美學和人體工程學方面的知識和技能(Eder, 2013; Pahl et al., 2007)。在與工業設計師的互動下，工程設計師參加了由工業設計師提出的設計概念的實施(Persson &amp; Warell, 2003)。工程設計人員為產品的功能，可靠和製造提供了一種方法(Hubka &amp; Eder, 2012; Pahl et al., 2007)。這導致了工業和工程設計師之間的有不同觀點(Cross, 2008; Hubka &amp; Eder, 2012)。</p>
<p><span>It is often argued that engineering designers use an ‘outward approach e developing from function to appearance’ whereas industrial designers follow an ‘inward approach e developing from appearance to functions’ (Eder, 2013; Hosnedl et al., 2008; Pahl et al., 2007). With these notions, the following two design strategies were proposed: one is the ‘inside-out’ strategy that is defined as designing the inner working parts first, and thus constraining the outside shape, and the other is the ‘outside-in’ strategy where the envelope was defined first, and thus constraining the inside parts (Hubka &amp; Eder, 2012; Kim &amp; Lee, 2010). These design strategies refer to combined design pro- cesses that a company should take for a specific purpose with particular con- ditions. However, little is known from empirical evidence about how these two strategies are applied in projects in industry. There have been few attempts to view the design process from an integrative perspective of engineering design and industrial design. In this regard, we investigated the collaborative design processes of both disciplines in the industrial context.</span></p>
<p>經常有人爭辯說，工程設計師使用”從外觀到功能發展的方式”，而工業設計師則採用<span class="mjx-chtml MathJax_CHTML" data-mathml='&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;&lt;mstyle displaystyle="true"&gt;&lt;mo&gt;&lt;/mo&gt;&lt;/mstyle&gt;&lt;/math&gt;' id="MathJax-Element-1-Frame" role="presentation" style="box-sizing: border-box; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 18.08px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; margin: 0px; padding: 1px 0px; position: relative;" tabindex="0"><span aria-hidden="true" class="mjx-math" id="MJXc-Node-1"><span class="mjx-mrow" id="MJXc-Node-2"><span class="mjx-mstyle" id="MJXc-Node-3"><span class="mjx-mrow" id="MJXc-Node-4"><span class="mjx-mo" id="MJXc-Node-5"></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mo></mo></mstyle></math></span></span>從外觀到功能發展的方式'(Eder, 2013; Hosnedl et al., 2008; Pahl et al., 2007)。基於這些概念，提出了以下兩種設計策略：一種是“由內而外”的策略，定義為首先設計內部工件及配件，從而限制外部形狀，另一種是“由外而內”的策略。首先定義外型，然後約束內部零件(Hubka &amp; Eder, 2012; Kim &amp; Lee, 2010)。這些設計策略涉及公司應在特定條件下為特定目的而採取的設計過程。但是，從經驗來看的證據中很少了解到這兩種策略如何在工業項目中應用。很少有嘗試從工程設計和工業設計的綜合角度來看待設計過程。在這方面，我們研究了工業環境中兩個學科的協作設計過程。</p>
<p><span>The research questions were: 1) what types of collaborative product design processes exist, and 2) what conditions drive a company to adopt a particular type of process. Based on the two designer groups’ roles and characteristics, we hypothesized that there would be different types of outside-in and inside- out design approaches. We assumed that the outside-in approach would be characterized by an industrial design-led design process, thus generating in- dustrial designer’s role as a requirement and criteria provider, and the inside-out approach would be an engineering design-led design process, where engineering designers restrict industrial designer’s task range by providing initial requirements for industrial designers’ responsibilities. In or- der to succeed in a highly competitive market, companies should create collaborative processes of industrial design and engineering design by prop- erly adopting outside-in and inside-out approaches to match their situations and objectives.</span></p>
<p>研究的問題是1:存在哪些類型的協作產品設計流程，以及2:什麼條件促使公司採用特定類型的流程。根據這兩個設計師小組的角色和特點，我們假設會有不同類型的由內而外的設計方法。我們認為，由內而外的方法將以工業設計為主導的設計過程為特徵，從而產生工業設計師作為需求和標準提供者的角色，而由內而外的方法將以工程設計為主導的設計過程，工程設計師通過提供對工業設計師職責的初始要求來限制工業設計師的任務範圍。為了在競爭激烈的市場中取得成功，公司應通過適當地採用從內而外的方法來匹配其情況和目標，從而創建工業設計和工程設計的協作流程。</p>
<p><span>This paper serves two goals: firstly, to shed light on the form of the original collaborative product design process applied in practice, and secondly to determine different types of processes used for different purposes under different conditions. For these purposes, we conducted in-depth interviews with industrial designers and engineering designers from six consumer product manufacturers. We determined each company’s product design processes us- ing a ‘mosaic method,’ where individual design processes drawn from interview data were combined to complete a collaborative process. As a result, we iden- tified four types of typical collaborative product design processes and their characteristics.</span></p>
<p>本文有兩個目標：首先，闡明在實踐中應用的原始協作產品設計過程的形式；其次，確定在不同條件下用於不同目的的不同類型的過程。為此，我們對六家消費產品製造商的工業設計師和工程設計師進行了深入採訪。我們使用“mosaic method”確定了每家公司的產品設計流程，其中結合了從訪談數據中提取的各個設計流程以完成協作流程。結果，我們確定了四種典型的協作產品設計流程及其特徵。</p>
<p><span>The recurring term ‘collaborative product design’ throughout this article refers to a product design created by the collaborative contribution of industrial design and engineering design. In particular, in corporate contexts, collabora- tive product design involves a series of design activities, such as the creation of initial product concepts, decisions on interior specifications, and the develop- ment of outer forms and inner structure. Hence, ‘collaborative product design process’ means the product design process in which both industrial design and engineering design are directly involved in product development activities.</span></p>
<p>在本文中，“協同產品設計”的用語是指通過工業設計和工程設計的共同貢獻而創建的產品設計。特別是在公司環境中，協同產品設計涉及一系列設計活動，例如:創建初始產品概念，確定內部規格以及開發外部特徵和內部結構。因此，“協同產品設計過程”是指工業設計和工程設計都直接參與產品開發活動的產品設計過程。</p>
<p><span>‘Industrial design’ at this point mostly concerns developing the outer forms, in- terfaces, and user experience of consumer products, excluding graphic-only or styling-only design. ‘Engineering design’ develops technical solutions for placing and operating internal functional parts in consumer products and defines inter- nal and external parts constituting products in a way that enables mass produc- tion. We labelled engineers engaged in such activities as ‘engineering designers’.</span></p>
<p><span>This article consists of three parts: The first part describes the research approach in detail. The second part presents typical collaborative product design processes and their characteristics as findings. Finally, it summarizes the results, and dis- cusses the implications and contribution to the design literature.</span></p>
<p>此時的“工業設計”主要涉及開發產品的外形，界面和用戶體驗，但不包括純圖形或純樣式的設計。 “工程設計”開發了用於在產品中放置和操作內部功能部件的技術解決方案，並以能夠實現大規模生產的方式定義了構成產品的內部和外部部件。我們將從事此類活動的工程師標記為“工程設計師”。</p>
<p>本文包括三個部分：第一部分詳細介紹了研究方法。第二部分介紹了典型的協作產品設計過程及其特徵。最後，它總結了結果，並討論了對設計文獻的影響和貢獻。</p>
<p><span><strong>1 Research approach</strong></span></p>
<p><span>To investigate the types of collaborative product design processes and related conditions, we adopted a grounded theory approach in data collection and analysis (Charmaz, 2006; Glaser &amp; Strauss, 2009), and a ‘mosaic method’ that we devised to reconstruct collaborative design processes between indus- trial designers and engineering designers. The grounded theory approach is widely used in social sciences as a systematic methodology to establish theory for less studied areas, while in design research it has been long adopted (e.g. Lee &amp; Cassidy, 2007; Wong, 2010). It uses inductive logic, starting with data collection mostly through in-depth interviews and/or observation. In the cod- ing stage, there are generally two strategies. One is to collect and encode mean- ingful references from the data, and group them into coding categories when research topics are not clearly defined. The other is to use predefined coding categories in line with a particular theme to identify related references when research topics are clearly defined. We used the latter strategy, because the design process has been widely studied. Adopting a similar method, Berends, Reymen, Stultiens, and Peutz (2011) investigated the design processes of five companies. Kleinsmann and Valkenburg (2003) collected stories about collaborative design processes in industry and identified key themes and plots of the collaborative design projects.</span></p>
<p>1.研究方法</p>
<p>為了研究協作產品設計過程的類型和相關條件，我們在數據收集和分析中採用了紮實的理論方法(Charmaz, 2006; Glaser &amp; Strauss, 2009)，以及我們設計用於重新構建協作設計過程的“鑲嵌方法”在工業設計師和工程設計師之間。紮根的理論方法在社會科學中被廣泛用作為研究，較少的領域有建立理論的系統方法，而在設計研究中已被長期採用(e.g. Lee &amp; Cassidy, 2007; Wong, 2010)。它使用歸納邏輯，主要是通過深入的訪談和或觀察開始進行數據收集。在編碼階段，通常有兩種策略。一種是從數據中收集有意義的參考資訊並進行編碼，如果研究主題沒有明確定義，則將它們分為編碼類別。另一種是在明確定義研究主題時，使用符合特定主題的預定義編碼類別來標識相關參考。我們使用了後一種策略，因為對設計過程進行了廣泛的研究。 Berends，Reymen，Stultiens和Peutz（2011）採用了類似的方法，對五家公司的設計過程進行了調查。 Kleinsmann和Valkenburg（2003）收集了有關工業中協同設計過程的事例，並確定了協同設計項目的關鍵主題和過程。</p>
<p><span>We firstly conducted in-depth interviews with individual designers and collected their stories about design projects. To avoid a possible distortion due to the unreliability or possible inaccuracy of retrospective accounts (Ackroyd &amp; Hughes, 1981), we adopted three criteria for selecting research tar- gets: (1) multiple companies in a similar product domain; (2) multiple partic- ipants from both engineering and industrial design departments; and (3) projects already completed through a whole product development cycle. We set the first criterion to improve the applicability of research results. Under- standing and analysing project contexts improve the applicability of design processes and methods (Gericke &amp; Blessing, 2012). Thus, investigating multi- ple companies with similar project contexts could provide better chances to apply the research results. With the second criterion, the data from multiple informants with different perspectives are complemented by each other to offset any potential bias (Miller, Cardinal, &amp; Glick, 1997). Finally, in retro- spective interviews, the design process can be determined through collecting and analysing the stories of design projects that are already completed through a whole product development cycle (Berends et al., 2011).</span></p>
<p>我們首先對個別設計師進行了深入採訪，並收集了他們關於設計項目的事例。為避免追溯性帳戶的不可靠性或準確性所造成的可能的失真（Ackroyd＆Hughes，1981），我們採用了三個標準來選擇研究目標：（1）相似產品領域中的多家公司； （2）工程和工業設計部門的多個參與者； （3）在整個產品開發週期中已經完成的項目。我們設置了第一個標準來提高研究結果的適用性。對項目環境的理解和分析提高了設計過程和方法的適用性（Gericke＆Blessing，2012）。因此，對具有相似項目環境的多家公司進行調查可能會提供更好的機會來應用研究結果。使用第二個標準，來自具有不同觀點的多個受試者的數據將相互補充，以抵消任何潛在的偏見（Miller，Cardinal和Glick，1997）。最後，在回顧性訪談中，可以通過收集和分析整個產品開發週期中已經完成的設計項目的事例來確定設計過程（Berends等，2011）。</p>
<p><span>In order to reconstruct product design processes based on transcribed inter- view data, we firstly identified ‘process elements’ and then drew out partial design processes that individual designers practiced. Next, we combined all partial processes in each company into collaborative product design processes using the ‘mosaic method.’ After constructing all detailed collaborative prod- uct design processes, we simplified them with ‘process chunks’ to identify the types of typical design processes. Finally, we visualized them as design process models. Figure 1 shows the research procedure.</span></p>
<p>為了基於轉錄的訪談數據重建產品設計過程，我們首先確定“過程元素”，然後繪製出各個設計師實踐的部分設計過程。接下來，我們使用“‘mosaic method”將每個公司的所有部分流程組合為協同產品設計流程。在構建了所有詳細的協同產品設計流程之後，我們使用“流程塊”對其進行了簡化，以識別典型設計流程的類型。最後，我們將它們可視化為設計過程模型。圖1顯示了研究過程。</p>
<p>圖1:<img alt="" height="375" src="https://s40723221.github.io/cd2020/images/c1.png" width="828"/></p>
<p><span>Actual design processes and their characteristics in reference to the context can be determined from actual design projects, which may be different from the documented design processes of the companies. Comparing both will provide insight. However, we could not collect them, because they are considered as confidential to the outside. Instead, we asked the interviewees whether their company has a documented standard design process and whether it is different from actual design processes.</span></p>
<p>可以根據實際設計項目確定實際設計過程及其相對於上下文的特徵，這可能與公司記錄的設計過程不同。比較兩者將提供洞察力。但是，我們無法收集它們，因為它們被視為對外部機密。取而代之的是，我們詢問受訪者他們的公司是否有書面的標准設計流程，以及它是否與實際設計流程不同。</p>
<p> </p>
<p><span>1.1 In-depth interview</span></p>
<p><span>1.1.1 Selection of case companies</span></p>
<p><span>To increase the applicability, the design process should be understood within the context and environment of a company (Maffin, 1998). As such, we set three criteria by specifying case companies to explore. The three criteria adop- ted are as follows:</span></p>
<p><span>1)The companies should produce mid-complex electronic consumer products.</span></p>
<p><span>2) They should have independent industrial design and engineering design departments.</span></p>
<p><span>3) They should be leading companies in the market producing well-designed high-quality products.</span></p>
<p>1.1深度訪談</p>
<p>1.1.1案例公司的選擇</p>
<p>為了增加適用性，應該在公司的環境和背景下理解設計過程（Maffin，1998）。因此，我們通過指定案例公司來設置三個標準。所採用的三個標準如下：</p>
<p>(1）公司應生產中等複雜的電子產品。</p>
<p>(2）他們應該有獨立的工業設計和工程設計部門。</p>
<p>(3）他們應該是市場上領先的公司，生產精心設計的高質量產品。</p>
<p><span>The first criterion enabled the selection of manufacturers with similar in prod- uct domain context wherein both industrial designers and engineering de- signers play important roles. Manufactures producing simple consumer products will require a lesser role from engineering designers. In addition, developing a rocket needs no industrial designer’s role. Ulrich and Eppinger (2012) stated that ‘electromechanical products of modest complexity’ requires equally important roles of industrial designers and engineering de- signers. Based on the classification of engineered consumer products with complexity proposed by Cross (2008), examples of modest complex products are electrical drills and washing machines. Thus, mid-complex electronic con- sumer products refer to everyday consumer electronics goods that are engi- neered products fully integrating electronic and mechanical systems (Vasic &amp; Lazarevic, 2008). Although, the first criterion is satisfied, some companies such as Original Equipment Manufacturers (OEM), or small companies have either one department of industrial design or engineering design, or none. In such cases, they use external design and/or engineering consulting firms. Their collaboration process would be different from that happening between in-house independent industrial design and engineering departments. We in- tended to increase the applicability of research results by exploring cases with similar contexts. Thus, the second criterion was fulfilled. Finally, leading companies producing well-designed and high-quality products could provide reasonable and proper data for investigation, and the findings would be a good source of reference for other companies. Lawson (1994) pointed out that discovering how good design practices take place would be beneficial to understand and prescribe methods more effective. This is the rationale for third criterion.</span></p>
<p>第一個標準使得能夠選擇在產品領域內具有相似性的製造商，其中工業設計師和工程設計者都扮演著重要的角色。生產簡單消費品的製造商在工程設計師中的作用將減少。此外，開發火箭不需要工業設計師。 Ulrich和Eppinger（2012）指出，“中等複雜度的機電產品”要求工業設計師和工程設計人員重要程度相同。根據Cross（2008）提出的具有復雜性的工程消費品分類，中等複雜產品的例子包括電鑽和洗衣機。因此，中等複雜的電子消費產品指的是日常消費電子產品，它們是完全集成了電子和機械系統的工程產品（Vasi c＆Lazarevi c，2008）。儘管滿足第一個條件，但是某些公司（例如原始設備製造商（OEM））或小型公司的工業設計或工程設計部門是一個，或者沒有。在這種情況下，他們會使用外部設計或工程諮詢公司。他們的協同過程將不同於內部獨立工業設計和工程部門之間的協同過程。我們傾向於通過探索具有相似背景的案例來提高研究結果的適用性。因此，滿足了第二個標準。最後，生產精心設計和高質量產品的領先公司可以為調查提供合理和適當的數據，研究結果將為其他公司提供很好的參考。Lawson（1994）指出，發現良好的設計實踐是如何發生的，將有助於理解和製訂更有效的方法。這是第三個標準的理由。</p>
<p><span>We selected the case companies with the above criteria. We firstly applied first and third criteria to the list of the companies that had won the ‘Korean Good Design Award’ from 2006 to 2010 (About GD, 2011) consecutively. The ‘Korean Good Design Award’ is popular among many market-leading manufacturers in Korea. As a result, we obtained 16 company names. Then, we contacted each company with contact information in the awardee lists, and asked the gatekeepers if they had independent ID and ED departments (second criterion) and if they were willing to participate in the study. Finally, we selected six companies (Table 1).</span></p>
<p>我們根據以上標準選擇了案例公司。我們首先將第一和第三項標準應用於從2006年至2010年連續獲得“韓國優秀設計獎”的公司（關於GD，2011年）。 “韓國優秀設計獎”在韓國許多市場領先的製造商中很受歡迎。結果，我們獲得了16個公司名稱。然後，我們與獲獎公司列表中的聯繫方式聯繫了每家公司，並詢問主管是否具有獨立的ID和ED部門（第二標準）以及他們是否願意參加研究。最後，我們選擇了六家公司（表1）。</p>
<p><span>1.1.2 Selection of interviewees</span></p>
<p><span>We selected interviewees with purposive and snowball sampling methods (Berg, 1988). The gatekeeper of each company suggested their designers who in turn suggested their co-workers. While doing so, we selected interviewees satisfying the three criteria below:</span></p>
<p>表1:<img alt="" height="202" src="https://s40723221.github.io/cd2020/images/c2.png" width="818"/></p>
<p>1.1.2選擇受訪者</p>
<p>我們選擇了具有目的性和滾雪球式抽樣方法的受訪者（Berg，1988）。每個公司的主管都建議他們的設計師，而後者又建議他們的同事。在這樣做的同時，我們選擇了滿足以下三個條件的受訪者：</p>
<p><span>（1) More than two years of experience in the company</span></p>
<p><span>（2) Engagement in at least one cycle of the product development process</span></p>
<p><span>（3) Close collaboration and interaction with counterparts (i.e. industrial de-</span></p>
<p><span>signers vs. engineering designers) </span></p>
<p>（1）兩年以上公司工作經驗</p>
<p>（2）參與至少一個產品開發過程的周期</p>
<p>（3）與同行的緊密合作和互動（即工業設計，</p>
<p>簽名人與工程設計師）</p>
<p><span>The intended number of interviewees recruited from industrial designer and engineering designer groups in a company was six, with three from each to keep the balance. However we were able to recruit only two engineering de- signers each from Company B and F. In total, 18 industrial designers and 16 engineering designers participated as interviewees. Their working experi- ence ranged from 2.1 to 20 years with an average of 8.9 years.</span></p>
<p>從一家公司的工業設計師和工程設計師團隊招募的預期受訪者人數為6名，每名受訪者中有3名為了保持平衡。但是，我們只能從B公司和F公司招募兩名工程設計人員。總共有18名工業設計師和16名工程設計師作為受訪者參加。他們的工作經驗從2.1年到20年不等，平均為8.9年。</p>
<p><span><strong>1.1.3 Interview procedure</strong></span></p>
<p><span>We employed a semi-structured in-depth interview method following sug- gested instruction from the literature (Kvale &amp; Brinkmann, 2009; Seidman, 2012). We firstly listed about 20 detailed questions and grouped them into four main themes: 1) personal information, 2) design process, 3) role and expertise, and 4) interaction.We then formulated four key questions:</span></p>
<p>1.1.3面試程序</p>
<p>根據文獻的建議，我們採用了半結構化深度訪談方法（Kvale＆Brinkmann，2009； Seidman，2012）。我們首先列出了約20個詳細問題，並將它們分為四個主要主題：(1）個人信息，(2）設計過程、(3）角色和專業知識以及(4）交互，然後提出了四個關鍵問題：</p>
<p><span>（1) What is your position and role in the team?</span></p>
<p><span>（2) How did the product design process proceed and what happened during</span></p>
<p><span>the process?</span></p>
<p><span>（3) What tasks did you have in the design process, and what knowledge and</span></p>
<p><span>skills you had required to carry out the projects?</span></p>
<p><span>（4) How did industrial design(ers) and engineering design(ers) interact with</span></p>
<p><span>each other during the design process?</span></p>
<p>（1）您在團隊中的職位和角色是什麼？</p>
<p>（2）產品設計過程如何進行以及在此過程中發生了什麼</p>
<p>過程？</p>
<p>（3）您在設計過程中擁有哪些任務，以及哪些知識和常識</p>
<p>您執行項目所需的技能？</p>
<p>（4）工業設計和工程設計如何相互作用</p>
<p>在設計過程中互相交流？</p>
<p><span>The interview started with the first question about interviewees’ roles in their teams and working experiences, followed by the product development processes they experienced and their tasks in such processes. When an inter- viewee hesitated to start talking because of inattention to specify a moment to recall, we provided a detailed context, e.g. ‘Assume that today is the kick- off meeting day for the project you were involved in, and then tell me about what happened.’ This followed the advice for good questioning in an inter- view study; assuming, alternative, ideal, and interpretive questions (Merriam, 1998). To restrict inconsistencies caused by multiple interviewers, one author performed all the interviews (Ahmed, 2007). Moreover, the author had 14 years of industry experience in product development, which limited the possibility of misunderstanding the composed design situation described by interviewees. To avoid bias regarding the interviewer’s experi- ence, this research followed the ‘Epoche’ process in which prejudgment and assumptions about a phenomenon are blocked in order to examine it in the world of participants (Leedy &amp; Ormrod, 2012). Therefore, the interviewer ignored prejudgment on the phenomenon when feeling like judging the in- terviewee’s response. We conducted the interviews in quiet rooms in each company, and audio-recorded all conversations. To help the conversation, and to record supplementary information, we made field notes. Sometimes, interviewees produced drawings on the note to provide a detailed description.</span></p>
<p>訪談首先是關於受訪者在團隊中的角色和工作經驗的問題，然後是他們經歷的產品開發過程以及在這些過程中的任務。當受訪者由於不願指出要回憶的時刻而猶豫不決時，我們提供了詳細的背景信息，例如：“假設今天是您參與的項目的開工會議日，然後告訴我發生了什麼事。”假設，替代，理想和解釋性問題（Merriam，1998年）。為了限制由多個訪問者引起的不一致，一位作者執行了所有訪問（Ahmed，2007年）。此外，作者在產品開發方面擁有14年的行業經驗，這限制了誤解受訪者描述的綜合設計情況的可能性。為了避免對面試官產生偏見，本研究遵循了“ Epoche”過程，該過程將對現象的判斷和假設封閉，以便在參與者的世界中進行檢查（Leedy＆Ormrod，2012年）。因此，面試官在感覺要判斷受訪者的反應時就忽略了對這種現象的判斷。我們在每個公司的會議室中進行了採訪，並對所有對話進行了錄音。為了幫助進行對話並記錄補充信息，我們做了現場說明。有時，受訪者會在便箋上製作圖紙以提供詳細說明。</p>
<p><span>It is known from experience that 90 min is appropriate for in-depth inter- view time, because informants respond to the interview earnestly within this time and informants’ responses tend to decrease as the time exceeds 90 min (Seidman, 2012). We had a planned interview time of 90 min following the guideline, but we did not control it. We closed interviews when we had enough data regarding the questions by observing that new information from responses is decreased. The ‘voice detection recording function’ in the recorder enabled us to pause recording with a silence for a few seconds and resume when the voice came back. The time of recording ranged from 70 to 100 min per interviewee with an average of 78.5 min for all participants. Therefore, the actual interview time per interviewee should be longer than the recording time. We transcribed all interview data verbatim. As a result, we obtained around 1000 pages of the overall transcription.</span></p>
<p>從經驗中知道，90分鐘適合進行深度訪談，因為受訪人在這段時間內會認真回答採訪，而受訪人在90分鐘以上時的回應往往會減少（Seidman，2012年）。遵循指南，我們計劃的採訪時間為90分鐘，但我們沒有控制住它。當我們有足夠的關於問題的數據時，我們通過觀察減少了來自答复的新信息，從而結束了訪談。錄音機中的“語音檢測錄音功能”使我們可以無聲地暫停錄音幾秒鐘，並在聲音返回時恢復錄音。每個受訪者的錄音時間從70分鐘到100分鐘不等，所有參與者的平均錄音時間為78.5分鐘。因此，每個受訪者的實際採訪時間應長於錄音時間。我們逐字記錄了所有採訪數據。結果，我們獲得了大約1000頁的全部轉錄。</p>
<p><span>1.2 Identifying design processes</span></p>
<p><span>1.2.1 Identifying design processes that each individual experienced</span></p>
<p><span>Although, all transcribed data contained information related to design pro- cesses, they were all intermingled with other contents, including the situation and goal of the project, individuals’ roles, necessary skills and knowledge, con- flicts between actors, perceived images of each other, etc. We firstly formulated a coding framework by reviewing related literature to identify ‘process ele- ments’ that were used for constructing the design process. We confirmed them by perusing Company A’s interview transcription several times. The two perspectives on process modelling, viewing processes as information pro- cessing and state-transition systems provide meaningful clues about coding categories of process elements for the modelling of a process.</span></p>
<p>1.2確定設計過程</p>
<p>1.2.1確定每個人經歷的設計過程</p>
<p>儘管所有轉錄數據都包含與設計過程有關的信息，但它們都與其他內容混合在一起，包括項目的情況和目標，個人的角色，必要的技能和知識，參與者之間的衝突，每個對象的感知圖像首先，通過回顧相關文獻來確定用於構建設計過程的“過程元素”，從而製定出一個編碼框架。我們通過仔細閱讀A公司的採訪記錄來確認他們。關於過程建模，將過程視為信息處理和狀態轉換系統的兩種觀點為有關過程建模的過程元素的編碼類別提供了有意義的線索。</p>
<p> </p>
<p><span>In the information processing perspective, Browning, Fricke, and Negele (2006) viewed product development and its activities as a process of informa- tion collection, creation, interpretation, transformation, and transfer. Most product development activities require a set of input and produce as outcomes of activities, preliminary outputs, status reports, etc. (Browning et al., 2006). This viewpoint has been supported by an extensive literature on design process and organization (e.g. Burns &amp; Stalker, 1961; Clark, 1991; Hubka &amp; Eder, 2012). Ulrich and Eppinger (2012) described this as information necessary for the final outcome that is injected to transform a current design problem to the next problem to lower uncertainty, and thereby producing output until the final outcome is formed. This is modelled as a process of transforming a functional specification (input) into an artefact specification (output) (Takeda, Veerkamp, &amp; Yoshikawa, 1990; Tomiyama &amp; Yoshikawa, 1986). Browning and Ramasesh (2007) pointed out that process modelling with the perspective of information processing fails to capture full information flow because interaction is poorly understood. They argued the importance of iden- tifying interactions between organizational units, because they incur depen- dency between activities that establish deliverable flow patterns. Conclusively, the basic elements of process modelling in this perspective are summarized as ‘information flow’ with the IPO (InputeProcesseOutput) rep- resentation and ‘interaction’ of organizational units (person, team, company, etc.).</span></p>
<p>從信息處理的角度來看，Browning，Fricke和Negele（2006）將產品開發及其活動視為信息收集，創建，解釋，轉換和轉移的過程。大多數產品開發活動需要一組輸入，並作為活動的結果，初步輸出，狀態報告等進行生產（Browning等，2006）。這種觀點得到了有關設計過程和組織的大量文獻的支持（例如Burns＆Stalker，1961; Clark，1991; Hubka＆Eder，2012）。 Ulrich和Eppinger（2012）將其描述為最終結果所必需的信息，該信息被注入以將當前設計問題轉換為下一個問題以降低不確定性，從而產生輸出，直到形成最終結果為止。這被建模為將功能規範（輸入）轉換為製品規範（輸出）的過程（Takeda，Veerkamp和Yoshikawa，1990； Tomiyama和Yoshikawa，1986）。 Browning和Ramasesh（2007）指出，由於對交互的了解不多，從信息處理的角度進行過程建模無法捕獲完整的信息流。他們認為，確定組織單位之間的相互作用的重要性，因為它們會引起建立可交付的流程模式的活動之間的依賴。最終，從這個角度來看，流程建模的基本元素概括為“信息流”與IPO（InputeProcesseOutput）表示以及組織單位（人員，團隊，公司等）的“互動”。</p>
<p><span>In the state-transition perspective, Reymen (2001) described a design process as the process of moving one state to another by performing a task at each stage and evaluating design activities. This is consistent with stage-gate models, where design activity happens at each stage and design output of the stage is evaluated at design review whereby a decision is made among whether to go to the next stage, repeat the current stage or reject the project (Cagan &amp; Vogel, 2002; Ulrich &amp; Eppinger, 2012). This perspective is advo- cated from most stage-based models (Wynn &amp; Clarkson, 2005). A stage- based model is made up of action that is intended to perform a task, and a decision that is to intended to evaluate the outcomes of performing the task; the completion of which constitutes progression to the next stage (J€ansch &amp; Birkhofer, 2006; Roozenburg &amp; Cross, 1991). Besides this, infor- mation flow accompanying input and output happens when jumping up from one stage to another or linking between sub-processes (Lindemann, 2003; Ogot &amp; Okudan-Kremer, 2004). The engineering design process model proposed by Pahl et al. (2007) demonstrates clear inputs and outcomes of each stage. The input of the first stage is ‘task’ and the outcome is ‘specifica- tion’ that goes into the next stage as an input yet again. In this way, the sequential developmental stages connecting inputs and outcomes are drawn out. Regarding the term ‘task’ and ‘design activity’, Pahl et al. (2007) uses ‘task’ to mean the initial starting point of the project different from ‘task’ executed at each stage. However, these two terms are used similarly to indi- cate performing design work, and thus there is a general consensus about the design process of connecting and proceeding tasks interdependently (Dorst, 2008).</span></p>
<p>從狀態轉換的角度來看，Reymen（2001）將設計過程描述為通過在每個階段執行任務並評估設計活動將狀態從一種狀態轉移到另一種狀態的過程。這與階段模型一致，在階段模型中，每個階段都會進行設計活動，並在設計評審中評估階段的設計輸出，從而決定是否進行下一階段，重複當前階段或拒絕項目。（Cagan＆Vogel，2002； Ulrich＆Eppinger，2012）。大多數基於階段的模型都提倡這種觀點（Wynn＆Clarkson，2005）。基於階段的模型由旨在執行任務的動作和旨在評估執行任務的結果的決策組成；這項工作的完成構成了下一階段的發展（J€ansch＆Birkhofer，2006； Roozenburg＆Cross，1991）。除此之外，當從一個階段跳到另一個階段或在子過程之間鏈接時，伴隨輸入和輸出的信息流就會發生（Lindemann，2003； Ogot和Okudan-Kremer，2004）。 Pahl等人提出的工程設計過程模型。 （2007）證明了每個階段的明確投入和成果。第一階段的輸入為“任務”，結果為“規範”，該輸入再次進入下一階段。這樣，繪製出了將輸入和結果連接起來的順序發展階段。關於“任務”和“設計活動”，Pahl等人。 （2007）使用“任務”來表示項目的初始起點，不同於在每個階段執行的“任務”。但是，這兩個術語的用法類似，用以表示執行設計工作，因此，人們對相互連接和處理任務的設計過程達成了普遍共識（Dorst，2008年）。</p>
<p><span>Taken into the state-transition perspective, there are two activities: performing task and evaluating outcomes. Mostly, evaluation happens within a relatively short period of time to decide between ‘go forward, repeat, or drop.’ Hence, we named these kinds of activities (evaluation, design review, gate check, deci- sion-making) as ‘event.’ At this juncture, we have two coding categories; ‘task’ and ‘event.’ In conclusion, we can model a design process with four cod- ing categories; ‘task,’ ‘event,’ ‘information flow,’ and ‘interaction,’ and can be represented with the connection of stages. At this point, a stage of a design process can be represented with ‘inputetask (design activity)eevent (deci- sion-making)eoutput.’ The followings describe how to encode process ele- ments with the above four coding categories.</span></p>
<p>從狀態轉換的角度來看，有兩個活動：執行任務和評估結果。通常，評估是在相對較短的時間內進行的，以便在“前進，重複或下降”之間做出決定。因此，我們將這些活動（評估，設計審查，門禁檢查，決策）稱為“事件”。目前，我們有兩個編碼類別；總而言之，我們可以用四個編碼類別對設計過程進行建模。“任務”，“事件”，“信息流”和“互動”，並且可以通過階段的關聯來表示。此時，設計過程的一個階段可以用“輸入任務（設計活動）事件（決策制定）輸出”來表示。以下內容描述如何使用以上四種編碼類別對過程要素進行編碼。</p>
<p><span>Task: Clear tasks that designers perform such as ‘idea sketches,’ ‘3D model- ling’, etc. A respondent said; ‘Yes, I do rough sketches with a ballpoint pen to express my idea. Little colouring on it or scan it to retouch on Photoshop.’ We encoded this into a task category with the label ‘idea sketch.’</span></p>
<p>任務：清除設計人員執行的任務，例如“想法草圖”，“ 3D建模”等。 ‘是的，我用圓珠筆粗略地表達了我的想法。它上的顏色很少，或者掃描後可以在Photoshop上進行修飾。”我們將其編碼為帶有“想法草圖”標籤的任務類別。</p>
<p><span>Event: After a particular task, an event (decision-making) proceeds, leading to the next action. A respondent said; ‘We go to the mock-up company to make prototypes, and bring all two or three prototypes. A mock-up evaluation meeting is held with them. . (omit) . the engineers listen to the boss’s crit- icism. The boss states this is this and that is that, then, if engineers have different ideas, they provide opinions .. (omit) . finally the one is selected. We encoded this with the label, ‘mock-up evaluation meeting,’ in the event category.</span></p>
<p>事件：完成特定任務後，將進行一個事件（決策），從而導致下一個動作。一位受訪者說； ‘我們去樣板公司製作原型，並帶走所有兩個或三個原型。與他們舉行了一次模擬評估會議 。工程師們聽老闆的批評。老闆說就是這樣，那就是，如果工程師有不同的想法，他們會提供意見..。最後一個被選中。我們在活動類別中使用“模擬評估會議”標籤對此進行了編碼。</p>
<p><span>Information Flow: Information flow is generated when a task or an event happens. It is always accompanied by input and output. A respondent said; ‘In fact, we work based on specifications received from engineering de- signers. We don’t start our work until something arrives.’ This describes that the industrial designers received ‘specification data’ from engineering designers as an input, with which they started their work. We encoded this ‘specification data from ED to ID.’ Another excerpt is; ‘. when one is selected, we pass the 3D Data of the mock-up to the engineering depart- ment. . (omit) . we send ‘STEP’ files, then they use ‘UG’ to start design.’ This describes that they sent 3D CAD data as the output of their design ac- tivity to engineering designers, which become an input for the following en- gineering design activity. We encoded this ‘3D CAD data from ID to ED.’</span></p>
<p>資訊交流：當任務或事件發生時會生成信息流。它總是伴隨著輸入和輸出。一位受訪者說； ‘事實上，我們根據工程設計人員提供的規范進行工作。我們要等到事情來臨時才開始工作。”這表示工業設計師從工程設計師那裡收到了輸入的“規格數據”作為他們開始工作的依據。我們對“從ED到ID的規範數據”進行了編碼。 ‘。選擇一個後，我們會將模型的3D數據傳遞到工程部門。我們發送“ STEP”文件，然後他們使用“ UG”開始設計。”這說明他們向工程設計人員發送了3D CAD數據作為其設計活動的輸出，這些輸入成為後續工程設計的輸入。活動。我們對“從ID到ED的3D CAD數據”進行了編碼。</p>
<p><span>Interaction: When a task or event takes place, the two groups frequently interact. For example, while industrial designers checked whether the inside space could be modified, engineering designers advised them by providing related information. In such cases, intensive interaction happens and the en- gineering designer serves as an ‘advisor.’ A response is the case; ‘They explain ‘this should be placed here and that should be placed there.’ Then, we modify the size and position and ask them again whether the 2-mm gap can be reduced. If they say ‘Yes,’ we flatten one part against another.’ We en- coded this as ‘advisor role of ED to ID.</span></p>
<p>交互：發生任務或事件時，兩組經常交互。例如，當工業設計師檢查是否可以修改內部空間時，工程設計師通過提供相關信息為他們提供建議。在這種情況下，會發生激烈的互動，而工程設計人員會充當“顧問”的角色。 ‘他們解釋說‘應該放在這裡，應該放在那裡。’然後，我們修改尺寸和位置，然後再次詢問他們是否可以減小2毫米的間隙。如果他們說“是”，我們會將一個部分與另一個部分拼合。”我們將其編碼為“ ED到ID的顧問角色”。</p>
<p><span>We identified process elements from every piece of transcribed interview data. We labelled them with the participant’s own word as far as possible. We used the field notes as a supplementary data source. While doing so, we arranged and connected the encoded elements in a flowchart format chronologically to construct partial design processes. This method is widely adopted to visu- alize process models in industry (Vergidis, Tiwari, &amp; Majeed, 2008). We also determined the project types and goals involved in the design processes from the interview data. Two researchers executed the whole procedures. One researcher firstly constructed partial design processes, and the other researcher examined them by inspecting the interview data. As a result, we obtained 45 partial design processes with 7-9 from each company (see the second row in Table 2).</span></p>
<p>我們從每個轉錄的訪談數據中識別出流程要素。我們盡可能用參與者自己的話語標記他們。我們將現場說明用作補充數據源。在此過程中，我們按時間順序排列並連接了編碼元素，以構建部分設計過程。該方法被廣泛採用以可視化行業中的過程模型（Vergidis，Tiwari和＆Majeed，2008年）。我們還根據訪談數據確定了設計過程中涉及的項目類型和目標。兩名研究人員執行了整個程序。一位研究人員首先構建了部分設計流程，另一位研究人員通過檢查訪談數據對其進行了檢查。結果，我們從每個公司用7-9獲得了45個局部設計過程（請參見表2中的第二行）。</p>
<p>表2:<img alt="" height="148" src="https://s40723221.github.io/cd2020/images/c3.png" width="828"/></p>
<p><span>1.2.2 Identifying collaborative product design processes</span></p>
<p><span>The next stage was to combine each company’s design processes into collabora- tive design processes via a ‘mosaic method.’ We firstly collected partial design processes from a particular project in a company. This was easily done because designers in a company described shared experiences in the same projects, whereby the individual partial design processes overlapped and supplemented each other. After that, we combined the partial processes by comparing and merging process elements. The partial processes extracted from industrial de- signers’ interview data provided rich information on industrial design activities, including interactive behaviours with engineering designers but less information on pure engineering design activities. This was also the case for engineering design. We merged partial processes from industrial designers in a company to rebuild the design processes around industrial design activities. At the same time, we used the information provided by engineering designers to supplement and strengthen the design activity flows from the engineering design side. We rebuilt the design processes around engineering design activities in the same way. We finally merged the two design processes into one collaborative product design process. In the mosaic method, combining the crosschecked partial pro- cesses is beneficial for higher reliability and commonality. This significantly reduced the likelihood of constructing a process with incomplete information by offsetting each other’s information. Thus, the ‘mosaic method’ decreased the possibility of constructing an inaccurate process.</span></p>
<p>1.2.2確定協作產品設計流程</p>
<p>下一步是通過“mosaic method”將每個公司的設計過程結合到協作設計過程中。我們首先從公司的特定項目中收集了部分設計過程。之所以容易做到這一點，是因為公司的設計師描述了同一項目中的共享經驗，因此各個局部設計過程相互重疊並相互補充。之後，我們通過比較和合併過程元素來合併部分過程。從工業設計者的訪談數據中提取的部分過程提供了有關工業設計活動的豐富信息，包括與工程設計師的互動行為，但有關純工程設計活動的信息較少。工程設計也是如此。我們將公司中工業設計師的部分流程合併在一起，以圍繞工業設計活動重建設計流程。同時，我們利用工程設計師提供的信息來補充和加強工程設計方面的設計活動流程。我們以相同的方式圍繞工程設計活動重建了設計流程。我們最終將這兩個設計過程合併為一個協作產品設計過程。在鑲嵌方法中，結合交叉檢查的局部過程有利於提高可靠性和通用性。通過抵消彼此的信息，這大大降低了構建信息不完整的流程的可能性。因此，“mosaic method”降低了構建不准確流程的可能性。</p>
<p><span>While comparing partial design processes, we found the product planning team was involved in some design process elements. Thus, we included its role. This implies that the product planning team plays a certain role in collab- orative design projects of industrial design and engineering design. We also standardized some terms that indicated the same tasks or events. But, they were encoded differently because interviewees had used them slightly differ- ently from each other. For example, we found that a meeting was encoded as ‘Product Planning Meeting’ in one partial design process and ‘Product Development Meeting’ in another. Thus, we unified them as ‘Product Planning Meeting.’ Some also called the industrial design outcome differently such as ‘mock-up,’ ‘design mock-up,’ or ‘mock-up fabrication.’ We unified them as ‘design mock-up.’ We also standardized ‘mock-up evaluation event’ and ‘mock-up selection’ as ‘mock-up evaluation event.’ This work was done by cross- checking interview data in each company while evaluating the meaning and context of the specific terms. Actually, designers seemed to understand each company’s documented design process where standard terminology was defined, but were not particularly conscious of it. It seemed that they ignored the standardized process because the market situation was pushing them to move fast. Language difference is also a possible cause of the term difference. In the product design area, native words and borrowed words are mixed in use in Korea. For example, we use both borrowed words and native words indi- cating ‘design’ in English. Besides, cultural and locational differences of the two teams are likely to cause term difference. Except for Company F, the two departments were located in different physical spaces, at least on different floors.</span></p>
<p>在比較部分設計過程時，我們發現產品計劃團隊參與了一些設計過程元素。因此，我們包括了它的作用。這意味著產品規劃團隊在工業設計和工程設計的協同設計項目中扮演著一定的角色。我們還標準化了一些表示相同任務或事件的術語。但是，它們的編碼方式不同，因為受訪者使用它們的方式略有不同。例如:我們發現一個會議在一個局部設計過程中被編碼為“產品計劃會議”，而在另一個局部設計過程中被編碼為“產品開發會議”。因此，我們將它們統一為“產品計劃會議”。也有人將工業設計結果稱為“模型”，“設計模型”或“模型製造”。我們將它們統一為“設計模型”。我們還將“模擬評估事件”和“模擬選擇”標準化為“模擬評估事件”。這項工作是通過對每個公司的面試數據進行交叉檢查，同時評估了評估的意義和環境來完成的。具體條款。實際上，設計師似乎了解每家公司定義了標準術語的文件化設計過程，但並沒有特別意識到這一點。他們似乎忽略了標準化流程，因為市場形勢迫使他們迅速採取行動。語言差異也是造成術語差異的可能原因。在產品設計領域，韓國語中的母語和借來的單詞混合使用。例如，我們同時使用借用詞和用英語表示“設計”的母語。此外，兩支球隊的文化和位置上的差異很可能會導致期限上的差異。除F公司外，這兩個部門分別位於不同的物理空間，至少位於不同的樓層。</p>
<p><span>Finally, we defined stages in a design process by merging stage elements (input, task, event, and output) into a box, and named them with related tasks (See Figure 2). For example, industrial designers start drawing various idea sketches based on research results of the previous stage. Then, they select a few best sketches through evaluation. According to the selection result, they decide to go to the next stage or repeat the current one. Therefore, the ‘idea sketch’ stage is composed of ‘research results (input),’ ‘idea sketch (task),’ ‘eval- uation (event),’ and ‘best sketches (output).’</span></p>
<p>最後，我們通過將階段元素（輸入，任務，事件和輸出）合併到一個框中並在其中將它們與相關任務進行命名，來定義設計過程中的階段（參見圖2）。例如，工業設計師開始根據前一階段的研究結果繪製各種構想草圖。然後，他們通過評估選擇一些最佳草圖。根據選擇的結果，他們決定進入下一階段或重複當前階段。因此，“想法草圖”階段由“研究結果（輸入），”想法草圖（任務），“評估（事件）”和“最佳草圖（輸出）”組成</p>
<p>圖2:<img alt="" height="379" src="https://s40723221.github.io/cd2020/images/c4.png" width="828"/></p>
<p><span>As a result, we obtained 12 collaborative product design processes from all companies; one to three from each company (see the third row in Table 2). We sent them to the informants of each company to check our interpreta- tion of their processes. There were minor changes made in this process. Figure 3 shows a collaborative product design process of Company A. It shows two parallel processes on either side: an industrial design process on the left and an engineering design process on the right, with the interac- tion between the two illustrated in the middle. A ‘product planning meeting’ in the middle is an event hosted by the ‘product planning team,’ where they make a decision, if they move forward to commercialize the concept or re- jected it. The text boxes are stages composed of input-task-event-output. Text boxes with dotted lines are not stages. They do not have all four- stage elements. For example, ‘inspection’ is a kind of decision. There is no input and output. The vertical arrows indicate the progress of the flow. It also shows the direction of information flow, where the output of the former stage becomes the input of the next stage. The horizontal arrows show the direction of ‘information flow’ or ‘interaction.’ The circular arrows represent repeated and strong interaction within the phases. Colours in Figures 3 and 5 show their connectivity. These are later categorized as phases and ex- plained in the next section.</span></p>
<p>結果，我們從所有公司獲得了12個協同產品設計流程；每個公司一到三個（請參閱表2中的第三行）。我們將它們發送給每個公司的受訪者，以檢查我們對其流程的解釋。在此過程中進行了較小的更改。圖3顯示了公司A的協作產品設計過程。它在兩側顯示了兩個並行的過程：左側是工業設計過程，右側是工程設計過程，中間示出了兩者之間的相互作用。中間的“產品規劃會議”是由“產品規劃小組”主持的活動，由他們決定是否繼續將概念商業化或拒絕。文本框是由輸入任務事件輸出組成的階段。帶有虛線的文本框不是階段。它們沒有所有四個階段的元素。例如，“檢查”是一種決定。沒有輸入和輸出。垂直箭頭指示流程的進度。它還顯示了信息流的方向，前一級的輸出變成了下一級的輸入。水平箭頭表示“信息流”或“交互”的方向。圓形箭頭表示各階段中反复且強烈的交互。圖3和5中的顏色顯示了它們的連通性。稍後將這些分類為階段，並在下一部分中進行說明。</p>
<p><span>1.2.3 Simplifying the processes</span></p>
<p><span>Once we formulated each company’s collaborative product design processes, we categorized them to determine the types, purposes, and conditions of them. Yet, as each company’s processes include detailed design actions and in- formation, it is not easy to compare them directly between companies. Thus, we simplified each company’s design processes with the concept of ‘process chunks’ to aid their comparability, while maintaining the essential characteristics.</span></p>
<p>1.2.3簡化流程</p>
<p>一旦我們制定了每個公司的協作產品設計流程，我們就將它們分類以確定它們的類型，目的和條件。但是，由於每個公司的流程都包含詳細的設計動作和信息，因此直接在公司之間進行比較並不容易。因此，我們通過“流程塊”的概念簡化了每個公司的設計流程，以幫助它們保持可比性，同時又保持基本特徵。</p>
<p><span>We found that there was a pattern in a group of small sequential stages. There is a major job completed going through all sequential stages. After completing it, a clear new phase starts with another job. We defined those small stages as ‘process chunks.’ It is characterized by initial input, internal iteration, decision- making, final outcome, and irreversible tendency (Figure 4). The internal process in a process chunk starts with the initial input and runs across small stages inside. Iteration or feedback can happen among small stages inside the chunk. Finally, they make the final decision about the final outcomes. This is a milestone indicating that the phase is to jump over to the next phase. For example, in Figure 3 in the blue block, the major job in this chunk is to develop a design concept executing six small stages. When they are in the rendering stage, they can go back in the idea sketch stage if the rendering out- comes are not satisfied at the rendering evaluation event. At the last stage, a design mock-up as the outcome is confirmed by a top management, and then it jumps to ‘product planning meeting.’</span></p>
<p>我們發現在一組小的連續階段中存在一種模式。所有主要階段都完成了一項主要工作。完成後，一個清晰的新階段從另一個工作開始。我們將這些小階段定義為“流程塊”。其特徵在於初始輸入，內部迭代，決策，最終結果和不可逆趨勢（圖4）。流程塊中的內部流程從初始輸入開始，並在內部的各個小階段中運行。迭代或反饋可能在塊內的各個小階段之間發生。最後，他們對最終結果做出最終決定。這是一個里程碑，指示該階段將跳到下一階段。例如，在圖3的藍色方框中，此塊的主要工作是開發執行六個小階段的設計概念。當他們處於渲染階段時，如果在渲染評估事件中不滿意渲染結果，則可以返回到構思草圖階段。在最後階段，設計樣機作為結果由高層管理人員確認，然後跳至“產品計劃會議”。</p>
<p><span>The process flow between the two process chunks has a little chance to be reversed after the previous outcome goes into the input of the next chunk. The cross-teams generally make the final design, which is approved by the top manager at each chunk. To go back to the previous chunk means that it could not meet the timeline to the market. Thus, there should be a top man- agement’s decision on the issue. Based on interview data, they would rather drop the project than go back to the previous phase. Iteration and feedback among phases are characterized in most stage-based models (Wynn &amp; Clarkson, 2005). Considering a process chunk or two parallel chunks as a phase in this study, however, the reverse iteration or feedback between phases seldom happens in actual situations. It happens between stages inside a chunk. Thus, it seems that the abandonment of a project is almost impossible between stages but possible between phases.</span></p>
<p>在前一個結果進入下一個過程塊的輸入之後，兩個過程塊之間的過程流幾乎沒有機會被逆轉。跨團隊通常進行最終設計，並由高層經理在每個工作組中批准。回到上一個區塊意味著它無法滿足市場時間表。因此，應該由最高管理層對此事做出決定。根據訪談數據，他們寧願放棄該項目，也不願返回上一個階段。在大多數基於階段的模型中都對階段之間的迭代和反饋進行了描述（Wynn＆Clarkson，2005）。但是，在本研究中，將一個過程塊或兩個並行塊視為一個階段，因此在實際情況中很少會發生階段之間的反向迭代或反饋。它發生在一個塊中的各個階段之間。因此，似乎在階段之間幾乎不可能放棄項目，但是在階段之間可以放棄。</p>
<p><span>We named the process chunks by their main jobs. While naming the chunks, we found that the term ‘concept design’ is used differently by engineering design and industrial design. Concept design in engineering design is about technical concepts related to how a product works by developing broad solu- tions to the working structure and functions (Haik &amp; Shahin, 2010; Kroll, Condoor, &amp; Jansson, 2001; Ullman, 2009). However, industrial designers decide the direction of product style and interaction at the concept design phase, which is represented with concept keywords, mood boards, idea sketches and user scenarios (Press &amp; Cooper, 2003; Tovey &amp; Harris, 1999; Vredenburg, Isensee, Righi, &amp; Design, 2001). Thus, we marked the concept</span></p>
<p><span>design activity of industrial designers as ‘Concept Design-I’ and that of engi- neering designers as ‘Concept Design-E.’</span></p>
<p> </p>
<p>我們通過其主要工作來命名流程塊。在命名這些過程塊時，我們發現“概念設計”一詞在工程設計和工業設計中的用法有所不同。工程設計中的概念設計是與技術概念有關的技術概念，該技術概念通過開發對工作結構和功能的廣泛解決方案來與產品的工作方式相關（Haik＆Shahin，2010; Kroll，Condoor，＆Jansson，2001; Ullman，2009）。但是，工業設計師在概念設計階段決定產品樣式和交互作用的方向，這由概念關鍵字，情緒板，想法草圖和用戶場景來表示（Press＆Cooper，2003； Tovey＆Harris，1999；Vredenburg，Isensee， Righi和＆Design，2001年）。因此，我們標記了這個概念工業設計師的設計活動稱為“ Concept Design-I”，而工程設計師的設計活動稱為“ Concept Design-E”。</p>
<p><span>Figure 5 is the simplified version of Figure 3. The coloured boxes in Figure 3 are simplified with the same coloured blocks in Figure 5. The blue block in Figure 3 becomes ‘Concept Design-I.’ ‘Product Planning Meeting’ in Figure 3 is defined as ‘Product Planning’ and visualized with an elongated hexagon. It is determined as a single phase as it is a separated and distinctive design activity. Inside the red block, there are two parallel process chunks; ‘Concept Design-E’ on right side (the small red box), that is the ‘main process chunk,’ and ‘Shape Modification’ on the left-hand side (yellow), a ‘correspond- ing chunk.’ These two chunks are not deemed separate phases because they are coupled with the start to the end inside the big red block. As such, interaction between the two designer groups is strong. To differentiate two parallel chunks, we represented the main chunk with thick solid lines and the corre- sponding chunk with light solid lines. In the green blocks, as there was a little difference in the design activities between all 12 processes, we combined the two sequential process chunks of detail design and testing and production into one. As such, we treated them as a single phase in this study. When the design process in the green block proceeds, industrial designers react from time to time based on engineering designers’ requests or their own purpose for design inspection. They usually called these activities as ‘Follow-up’ differ- entiating from their major tasks. These kinds of activities apparently existed but do not belong to a process chunk. They are discrete process elements as shown in Figure 3, and thus represented with dotted lines. To help visual un- derstanding, solid arrows, a double directional wide arrow, and a single direc- tional wide arrow represent process flow, mutual interaction, and one-way interaction respectively.</span></p>
<p>圖5是圖3的簡化版本。圖3中的彩色框使用圖5中的相同彩色框進行了簡化。圖3中的藍色框變為“概念設計-I”。圖3中的“產品計劃會議”為定義為“產品計劃”，並以細長的六邊形可視化。由於它是一個單獨且獨特的設計活動，因此被確定為單個階段。在紅色塊內部，有兩個並行的處理塊；右邊的“ Concept Design-E”（紅色的小方框）是“主流程塊”，左邊的是“形狀修改”（黃色），是“對應的塊”。塊並不能視為單獨的階段，因為它們與大紅色塊內的開始到結束相結合。這樣，兩個設計師團隊之間的互動就很強。為了區分兩個平行的塊，我們用粗實線表示主塊，並用淺實線表示相應的塊。在綠色塊中，由於所有12個流程之間的設計活動都沒有什麼區別，因此我們將詳細設計，測試和生產的兩個順序流程塊合併為一個。因此，在本研究中我們將它們視為一個階段。當綠色方框中的設計過程繼續進行時，工業設計師會根據工程設計師的要求或他們自己的設計檢查目的不時做出反應。他們通常將這些活動稱為“後續活動”，與主要任務有所不同。這些活動顯然存在，但不屬於流程塊。它們是如圖3所示的離散過程元素，因此用虛線表示。為了幫助視覺理解，實心箭頭，雙向寬箭頭和單個方向寬箭頭分別表示過程流，相互交互和單向交互。</p>
<p>圖3:<img alt="" height="1153" src="https://s40723221.github.io/cd2020/images/c5.png" width="828"/></p>
<p>圖4:<img alt="" height="458" src="https://s40723221.github.io/cd2020/images/c6.png" width="609"/></p>
<p>圖5:<img alt="" height="1178" src="https://s40723221.github.io/cd2020/images/c7.png" width="828"/></p>
<p> </p>
<p><span>1.2.4 Determining types of collaborative design processes</span></p>
<p><span>We compared and categorized the 12 simplified collaborative product design processes based on similarities in their process structure, input and outcomes of process chunks and phases, and interaction between industrial designers and engineering designers. We first compared every process chunk and phase with corresponding process chunks and phases from the other 11 processes in terms of structure. Then, we compared inputs and outcomes of every corre- sponding phase across the 12 processes. For example, the ‘Concept Design-I’ phase in Figure 5 has no input, but produces ‘design mock-up’ as an output. Some ‘Concept Design-I’ phases in other processes started with the receipt of the preliminary layout from the engineering design teams. Therefore, examining the types of inputs and outcomes of phases give a clue to determine how the over- all process flows. Finally, we evaluated the interaction between industrial de- signers and engineering designers within a phase. There is no interaction between the two groups in the blue block. However, in the red blocks, there are strong interactions between them. As a result, we grouped the 12 collabora- tive product design processes into four types of representative processes.</span></p>
<p>1.2.4確定協作設計過程的類型</p>
<p>我們根據流程結構，流程塊和階段的輸入和結果的相似性以及工業設計師和工程設計師之間的交互性，對12個簡化的協同產品設計流程進行了比較和分類。我們首先將每個流程塊和階段與其他11個流程的相應流程塊和階段進行結構比較。然後，我們比較了12個流程中每個相應階段的投入和結果。例如，圖5中的“概念設計-I”階段沒有輸入，但是產生了“設計模型”作為輸出。其他流程中的某些“概念設計-I”階段始於工程設計團隊的初步佈局設計。因此，檢查階段的輸入和結果的類型為確定總體流程如何進行提供了線索。最後，我們評估了一個階段中工業設計人員與工程設計人員之間的互動。藍色方框中的兩個組之間沒有交互。但是，在紅色塊中，它們之間存在強大的交互作用。結果，我們將12個協作產品設計過程分為四種代表性過程。</p>
<p><span>2 Types of collaborative product design processes</span></p>
<p><span>We named the four types of collaborative product design processes based on their characteristics. They are Type 1: ID-led Concept-driven Process; Type 2: ID-led Combined Outside-inside Process; Type 3: ED-led Inside-ﬁrst Process; and Type 4: ID&amp;ED Synergetic Process, and diﬀerences between them are mostly found in the early phases of the processes where design concepts and preliminary layouts are developed. There is a little diﬀerence after the detail design phase where the engineering designers’ tasks dominate. It is rather standardized. This indicated that the types of collaborative product design processes are determined by the approaches adopted before the detail design phase.</span></p>
<p>2.協作產品設計過程的類型</p>
<p>我們根據協作產品設計過程的特徵來命名四種類型。它們是類型1：由ID主導的概念驅動過程；類型2：由ID領導的內外聯合流程；類型3：ED主導的內部流程；和類型4：ID＆ED協同過程，它們之間的差異主要存在於開發設計概念和初步佈局的過程的早期階段。在詳細設計階段之後，工程設計師的任務占主導地位，這之間存在一些差異。它相當標準化。這表明協作產品設計過程的類型由詳細設計階段之前採用的方法確定。</p>
<p><span>The companies adopted one to three types of design processes according to their goals and situations (See Table 3). Type 1 and 4 were used only for new designs except Company C which adopted Type 1 when the market requested a new styling within a short period of time. This happened when they had many reference products and lead-time was short. Type 2 was used for both new design and redesign. Interestingly, Type 3 was utilized only for redesign. Most processes were used for B2C except in Company C, ‘a mobile communication product manufacturer,’ which releases its products to the market through service providers. Considering that, Company C used Type 1 in a diﬀerent situation from Company A and E, the business type (B2B or B2C) would aﬀect the choice of design processes.</span></p>
<p><span lang="en">兩家公司根據其目標和情況採用了一到三種類型的設計流程（請參見表3）。類型1和4僅用於新設計，但C公司在市場要求在短時間內進行新樣式時採用了類型1。當他們有很多參考產品並且交貨時間很短時，就會發生這種情況。 Type 2用於新設計和重新設計。有趣的是，類型3僅用於重新設計。除公司C（“移動通信產品製造商”）通過服務提供商向市場發布其產品外，大多數流程都用於B2C。考慮到C公司在與A公司和E公司不同的情況下使用Type 1，業務類型（B2B或B2C）將影響設計流程的選擇。</span></p>
<p><span>Regarding the diﬀerence between actual design process and documented process, most of them responded that they have documented standard design processes in all companies, but they do not follow at all. This is supported by the ﬁnding by Maﬃn (1998) that designers develop their own approaches in accordance with product development context. It seemed that the documented process deﬁned standardized task ﬂows and stages, tasks and roles of each department, and project time according to project types. However, they were always pushed to shorten the actual project time. This kind of management pressure likely causes them not to follow the documented process.</span></p>
<p><span lang="en">關於實際設計過程和書面過程之間的區別，大多數人回答說他們已經記錄了所有公司的標准設計過程，但根本沒有遵循。 Ma ﬃ n（1998）的發現支持了這一點，即設計師根據產品開發環境開發了自己的方法。似乎已記錄在案件的流程根據項目類型定義了標準化的任務流和階段，每個部門的任務和角色以及項目時間。但是，他們總是被迫縮短實際項目時間。這種管理壓力很可能導致他們不遵循記錄的流程。 表3: </span></p>
<p><span>By comparing the frequency of use of each type of process, we found that Type 3 was the most frequently used, whereas Type 4 was the least. Type 2 was used more frequently than Type 1. Except in the case of Company B, Type 3 is most similar to that most interviewees described as the company standard. Considering the argument that redesign occurs more frequently than new design (Roozenburg &amp; Eekels, 1995) and successful radical innovation happens perhaps once every 5e10 years (Norman &amp; Verganti, 2014), this is a reasonable ﬁnding. As Type 4 is spontaneously initiated by individuals, and is not a set of oﬃcial, standard procedures, the case is rare. The detailed characteristics of each type of design process along with related contexts are described in the following sections.</span></p>
<p><span lang="en">通過比較每種類型過程的使用頻率，我們發現類型3是最常用的，而類型4是最少的。使用類型2的頻率比使用類型1的頻率更高。除了公司B的情況外，類型3與大多數受訪者所說的公司標準最為相似。考慮到重新設計比新設計更頻繁發生的論點（Roozenburg＆Eekels，1995），成功的徹底創新可能每5-10年發生一次（Norman＆Verganti，2014），這是一個合理的發現。由於類型4是個人自發發起的，並且不是一套官方的標準程序，因此這種情況很少見。以下各節介紹了每種類型的設計過程的詳細特徵以及相關的上下文。2.1 Type 1: ID-led Concept-driven ProcessIndustrial designers play a dominant role in deciding the direction of product development in the initial stage in Type 1. It has four phases in accordance with the process chunks, as shown in Figure 6.2.1類型1：由ID主導的概念驅動的過程工業設計人員在決定類型1初始階段的產品開發方向方面起著主導作用。根據過程塊，它分為四個階段，如圖6所示。</span></p>
<p><span>1st phase (Concept Design-I): Industrial designers independently develop the concept of a product without any interference from other departments. They focus mostly on the aspects relevant to the aesthetic exterior and user experience. They rarely consider the internal parts, which gives a lot of freedom to them. They produce 3D CAD data for the exterior and high-quality rendered images to test the concept. Once the exterior form is ﬁnally decided, they produce a ‘design mock-up,’ a non-functional prototype, to verify the concept. Finally, the best design is selected at a ‘design evaluation meeting.’ The ﬁnal outcomes in this phase are the 3D CAD data of outer shape and a design mock-up. Engineering designers do not take any action in this phase. Mostly, they are not even aware of what the industrial designers are designing.</span></p>
<p><span lang="en">第一階段（概念設計-I）：工業設計師獨立開發產品的概念，而不受其他部門的干擾。他們主要關注與美學外觀和用戶體驗有關的方面。他們很少考慮內部零件，這給了他們很多自由。他們為外部和高質量渲染圖像生成3D CAD數據以測試該概念。最終確定外觀形式後，他們會生成一個“設計模型”，一個無功能的原型，以驗證該概念。最後，在“設計評估會議”上選擇最佳設計。此階段的最終結果是外形的3D CAD數據和設計模型。工程設計師在此階段不採取任何行動。通常，他們甚至不知道工業設計師在設計什麼。</span></p>
<p><span>2nd phase (ProductPlanning): The product planningdepartmentdecides onthe commercialization of the selected design as well as on the target market, target price and material cost of the design. Finally, they prepare a product-planning document and establish a speciﬁc direction for commercialization of the design.</span></p>
<p><span lang="en">第二階段（產品計劃）：產品計劃部門決定所選設計的商業化以及目標市場，設計的目標價格和材料成本。最後，他們準備一份產品計劃文件，並確定設計商業化的具體方向。 </span></p>
<p>圖6:<img alt="" height="406" src="https://s40723221.github.io/cd2020/images/c8.png" width="714"/></p>
<p><span>3rd phase (Concept Design-E/Shape Modiﬁcation): The product planning document from the previous phase and the ﬁnal 3D CAD data developed by industrial designers are the initial inputs given to the engineering designers. Engineering designers review the feasibility of the design concept proposed by the industrial designers due to which engineering designers gather relevant technologies and arrange inner parts in the 3D CAD data to test if all indispensable internal functional parts can be ﬁxed inside the exterior form. Sometimes, engineering designers produce experimental prototypes to test if the desired performance can be implemented with the pre-set exterior form. As industrial designers did not consider the internal parts in deﬁning the exterior form, engineering designers have trouble in arranging the inner parts within the given form. Thus, modifying the exterior form is somehow unavoidable. Therefore, there is a corresponding process to Concept Design-E: ‘Shape Modiﬁcation’ by industrial designers. Industrial designers use the layout data received from engineering designers to modify the exterior form. At this point, two goals collide with each other. Industrial designers try to maintain the original form, while engineering designers demand the modiﬁcation to ensure functionality and performance. In this process, a very close interaction takes place. The outcome is 3D CAD data about the exterior form and interior part layout.</span></p>
<p><span lang="en">第三階段（概念設計-E /形狀修改）：前一階段的產品規劃文檔和由工業設計師開發的最終3D CAD數據是向工程設計師提供的初始輸入。工程設計人員回顧了工業設計人員提出的設計概念的可行性，因為工程設計人員收集了相關技術並在3D CAD數據中佈置了內部零件，以測試是否可以將所有必不可少的內部功能零件固定在外部表格中。有時，工程設計人員會生成實驗性原型，以測試是否可以通過預設的外觀形式實現所需的性能。由於工業設計師在定義外觀形式時未考慮內部零件，因此工程設計師在將內部零件佈置在給定的形式中時遇到了麻煩。因此，以某種方式不可避免地要改變外觀。因此，Concept Design-E有一個相應的過程：工業設計師的“形狀修改”。工業設計師使用從工程設計師那裡收到的佈局數據來修改外觀形式。此時，兩個目標相互碰撞。工業設計人員嘗試保持原始形式，而工程設計人員要求進行修改以確保功能和性能。在這個過程中，發生了非常緊密的交互。結果是有關外部形狀和內部零件佈局的3D CAD數據。</span></p>
<p><span>4th phase (Detail design  testing &amp; production/Follow-up): From this phase, engineering designers lead the process in all parts. Engineering designers decide on individual parts’ geometry and compositional structure based on the 3D CAD data determined at the previous phase. Due to the consideration of mass production or reliability testing, they sometimes ask industrial designers to make minor modiﬁcations of the exterior design. Upon completion of the detailed design, working prototypes called ‘engineering samples’ are produced to check the form and functionality. At this point, industrial designers evaluate to what extent the exterior form has been produced in compliance with their design concept. Then, engineering designers decide on suppliers, produce moulds, and test ‘pre-production prototypes’ through multiple event processes to improve the reliability of performance and the durability of the product.</span></p>
<p><span lang="en">第四階段（詳細設計測試和生產/跟進）：從這一階段開始，工程設計師在所有零件中領導該過程。工程設計人員根據上一階段確定的3D CAD數據來決定各個零件的幾何形狀和成分結構。由於考慮了批量生產或可靠性測試，他們有時會要求工業設計師對外觀設計進行較小的修改。詳細設計完成後，將生產稱為“工程樣品”的工作原型，以檢查形式和功能。在這一點上，工業設計師要評估其外觀設計符合其設計理念的程度。然後，工程設計師決定供應商，生產模具，並通過多個事件過程測試“生產前原型”，以提高性能的可靠性和產品的耐用性。</span></p>
<p><span>On the other side, in ‘Follow-up,’ industrial designers decide on how to apply colour, graphics, material, and surface ﬁnishing to the product and provide relevant speciﬁcations for engineering designers. For each working prototype produced, industrial designers test the aesthetic and emotional quality with the speciﬁcations. When they give their approval, their oﬃcial role in the design process ends. Unless they give an approval, engineering designers should produce and test the parts in a question again. We found that all six companies have this mechanism for maintaining the design quality of products.</span></p>
<p><span lang="en">另一方面，在“跟進”中，工業設計師決定如何在產品上應用顏色，圖形，材料和表面修飾，並為工程設計師提供相關規範。對於所生產的每個工作原型，工業設計師都會根據規格測試美學和情感品質。當他們批准時，他們在設計過程中的正式作用就結束了。除非獲得批准，否則工程設計師應再次生產和測試有問題的零件。我們發現所有六個公司都具有這種機制來維持產品的設計質量。</span></p>
<p><span>Type 1 is opposed to the conventional belief that a new product development process starts by identifying market needs via market research, or by developing new technology. It starts with pure industrial designers’ conceptualization with full freedom. This implies that new products can be developed based on pictures that industrial designers envision in their minds. This is inconsistent with product design processes described in the engineering design discipline (e.g. in Dym, 1994; Haik &amp; Shahin, 2010; Pahl et al., 2007), where industrial designers’ roles in concept design are missing.</span></p>
<p><span lang="en">類型1與傳統觀念相反，傳統觀念認為新產品開發過程是通過市場研究或開發新技術來確定市場需求而開始的。它始於純粹的工業設計師的完全自由的概念化。這意味著可以根據工業設計師在腦海中設想的圖片來開發新產品。這與工程設計學科中描述的產品設計過程不一致（例如，Dym，1994年； Haik＆Shahin，2010年； Pahl等，2007年），在工業設計中，工業設計師在概念設計中的作用缺失。</span></p>
<p><span>Considering the related theories which suggest that creativity happens before the thorough analysis of the problems in a solution-oriented approach (Wynn &amp; Clarkson, 2005), such as ‘primary generators’(Darke, 1979), and the conjecture-analysis model (Hillier, Musgrove, &amp; O’Sullivan, 1972), and other related ﬁndings and argument from Lawson (2006) and March (1984), that would be best strategies for a company to give industrial designers freedom and autonomy in generating creative solution concepts without external interference. In fact, Type 1 is employed in two situations: one is to develop new concept products in both shape and function, including the development of new product categories (as in Companies A and E), and the other is to launch a new model of an existing product as quickly as possible (as in Company C). The latter case appears to be possible when there are abundant reference designs so that industrial designers are able to decide on product sizes and exterior elements without any product speciﬁcation when the lead-time is short.</span></p>
<p><span lang="en">考慮到相關的理論，即創造力是在以解決方案為導向的方法（Wynn＆Clarkson，2005）對問題進行徹底分析之前發生的，例如“主要生成器”（Darke，1979）和猜想分析模型（Hillier）。 ，Musgrove和O'Sullivan，1972年），以及Lawson（2006年）和March（1984年）的其他相關發現和觀點，這將是公司在沒有外部影響的情況下，賦予工業設計師自由和自主權來產生創造性解決方案概念的最佳策略。干擾。實際上，類型1在兩種情況下被使用：一種是開發形狀和功能都新的概念產品，包括開發新產品類別（如公司A和E中的產品），另一種是啟動新概念產品。盡快（如公司C中）的現有產品。當參考設計豐富時，後一種情況似乎是可能的，因此，工業設計師可以在交貨時間短時確定產品尺寸和外部元素而無需任何產品規格。</span></p>
<p><span lang="en"><span>2.2 Type 2: ID-led Combined Outside-inside Process The companies use this process to develop new types of products or modify existing ones. In either case, unlike in Type 1, the product planning team starts the process. We can explain Type 2 in four phases as shown in Figure 7.</span></span></p>
<p><span lang="en"><span><br/></span>2.2類型2：由ID領導的組合內外流程 公司使用此過程來開發新型產品或修改現有產品。在任何一種情況下，與類型1不同，產品計劃團隊都將啟動該過程。我們可以分四個階段來解釋類型2，如圖7所示。 圖7: </span></p>
<p><span>1stphase(ProductPlanning):Theproductplanningteamcreatesaproductplanning document to initiate a product development. It sets up a target market, target price, and product speciﬁcation. When developing a modiﬁed version of existing products, itdecides on them in linewiththe existingproducts, including those of competitors. When developing a new product, engineering designers helpdecideonthem.Theoutcomeofthisphaseisaproductplanningdocument.</span></p>
<p><span lang="en">第一階段（產品計劃）：產品計劃小組創建一個產品計劃文檔以啟動產品開發。它設置了目標市場，目標價格和產品規格。在開發現有產品的修改版本時，它會根據現有產品（包括競爭對手的產品）來決定它們。在開發新產品時，工程設計師會幫助他們確定。此階段的結果是產品規劃文檔。</span></p>
<p><span lang="en"><span>2nd phase (Concept Design-I): Upon receiving the product planning document from the product planning department, industrial designers decide on the product’s exterior and related interior. They collect functional items needed for the product being developed in compliance with the product size and speciﬁcation, and also derive form concepts from research on users or design trends. Then, they arrange the interior parts to decide on the exterior form while avoiding any collision between the interior parts and the intended exterior form. Thus, they go back and forth between the outer shape design and the arrangement of the inside parts. There was a little interaction between industrial designers and engineering designers in this phase. For the ﬁnal event, design evaluation proceeds with non-functional design mock-ups. Thus, the outcome in this phase is the 3D CAD data concerning the exterior form and the initial interior layout of the product, and a design mock-up.</span></span></p>
<p><span lang="en">第二階段（概念設計-I）：從產品計劃部門收到產品計劃文件後，工業設計師將決定產品的外觀和相關內部。他們收集符合產品尺寸和規格的待開發產品所需的功能項目，並從對用戶或設計趨勢的研究中得出形式概念。然後，他們安排內部零件以決定外觀形式，同時避免內部零件與預期的外部形式之間發生任何衝突。因此，它們在外形設計和內部零件的佈置之間來回移動。在此階段，工業設計師和工程設計師之間幾乎沒有互動。對於最終事件，設計評估將使用非功能性設計模型進行。因此，此階段的結果是有關產品外觀和初始內部佈局的3D CAD數據，以及設計模型。</span></p>
<p><span lang="en"><span>3rd phase (Concept Design-E/Shape Modiﬁcation): Upon receiving the 3D CAD data from industrial designers, engineering designers closely inspect the feasibility and operability of the interior parts in connection with the exterior form and develop the ﬁnal layout. While engineering designers check them, and frequently request industrial designers to modify the layout or the outside form. Thus, industrial design activities proceed with a corresponding process; ‘Shape Modiﬁcation.’ However, the form change is not as signiﬁcant as in Type1 because they decided the exterior form in connection with the interior parts in the previous phase. The outcome in this phase is the 3D CAD data about the ﬁnal exterior form and the deﬁnitive layout of the interior parts.</span></span></p>
<p><span lang="en">第三階段（概念設計-E /形狀修改）：從工業設計師那裡獲得3D CAD數據後，工程設計師會仔細檢查內部零件與外部形狀相關的可行性和可操作性，並製定最終佈局。工程設計師檢查它們時，經常要求工業設計師修改佈局或外部形式。因此，工業設計活動要進行相應的過程。 “形狀修改”。但是，形狀更改不像Type1那樣重要，因為他們在上一階段決定了與內部部件相關的外部形狀。該階段的結果是有關最終外觀形式和內部零件確定佈局的3D CAD數據。4th phase (Detail design  testing &amp; production/Follow-up): This phase is not signiﬁcantly diﬀerent from that in Type 1.第四階段（詳細設計測試和生產/跟進）：該階段與類型1並無顯著差異。</span></p>
<p><span>A notable characteristic of Type 2 is industrial designers’ active involvement in arranginginnerfunctionalcomponentswhiledecidingtheoutershapeinthe2nd phase. Although industrial designers’ knowledge of thelinkage between interior layout and the outer shape is less engineering-focused, this case clearly demonstrates that the role of industrial designers has extended beyond what we normallyexpect.Asaresult,theindustrialdesignersbecomeinﬂuentialandtake the initiative in decision-making. In addition, engineering designers are hardly involved in this phase. We expected that layout design would be an exclusive job of engineering designers, as suggested by the engineering design literature (e.g. Hubka &amp; Eder, 1987; Pahl et al., 2007; Ullman, 2009). We assumed that atleastengineeringdesigners would activelyprovide adviceandguidancefor industrial designers. However, they expected the data to arrive from industrial designers and granted industrial designers freedom to complete outside form in connection with the inside structure of a product. The design-ﬁrst policy of the company seems to be the main reason at this point.</span></p>
<p><span lang="en">類型2的顯著特徵是工業設計師在確定第二階段的外形時積極參與佈置功能性組件。儘管工業設計師對內部佈局與外部形狀之間的聯繫的了解較少以工程為重點，但此案例清楚地表明，工業設計師的作用已經超出了我們通常期望的範圍。因此，工業設計師變得很有潛力並且可以主動地進行決策。此外，工程設計師幾乎沒有參與此階段。根據工程設計文獻的建議（例如Hubka＆Eder，1987; Pahl et al。，2007; Ullman，2009），我們希望版圖設計將是工程設計人員的專屬工作。我們假設至少工程設計人員會積極為工業設計師提供建議和指導。但是，他們希望數據能夠從工業設計師那裡獲得，並賦予工業設計師自由完成與產品內部結構有關的外部形式的能力。此時，公司的設計第一政策似乎是主要原因。</span></p>
<p><span>2.3 Type 3: ED-led Inside-ﬁrst Process Type 3 is diﬀerent from Type 1 and Type 2 in two points: they use it only to redesign the existing products, and engineering designers’ activities proceed prior to industrial designers. It requires a more prominent role for engineering designers while reducing the role of the industrial designers. We explain their characteristics as follows:</span></p>
<p><span lang="en">2.3類型3：由ED主導的內部第一個過程類型3與類型1和類型2有兩點不同：它們僅用於重新設計現有產品，工程設計人員的工作要先於工業設計人員進行。它要求工程設計師扮演更重要的角色，同時減少工業設計師的角色。我們解釋它們的特徵如下：</span></p>
<p><span>1st phase (Product Planning): As shown in Figure 8, the product planning team ﬁrstly initiates the product development project based on the annual roadmap of product development. At this point, they do have a functional concept of the products in the roadmap. Product planning experts determine the target market, target price, product size, and material costs based on the existing products in the market. Frequently engineering designers help them develop the product speciﬁcation by analysing technical parts of competitors’ products and estimating the material cost. The outcome of this phase is the product-planning document, which includes product speciﬁcation.</span></p>
<p><span lang="en">第一階段（產品計劃）：如圖8所示，產品計劃團隊首先根據年度產品開發路線圖啟動產品開發項目。至此，他們在路線圖中確實具有產品的功能概念。產品規劃專家根據市場上現有的產品確定目標市場，目標價格，產品尺寸和材料成本。工程設計人員經常通過分析競爭對手產品的技術部分並估算材料成本來幫助他們開發產品規格。此階段的結果是產品計劃文件，其中包括產品規格。</span></p>
<p><span>2nd phase (Concept Design-E): Engineering designers rapidly develop a preliminary layout based on the product speciﬁcation. They commonly use the data of previously developed products. Upon its completion, they send the preliminary layout as 3D CAD data to industrial designers. This is the starting point of industrial design process. Industrial designers use it as an input to develop the exterior form, while engineering designers seek solutions for system performance and continue to reﬁne the layout. As the interior layout and the exterior form develop simultaneously, both teams closely interact and discuss any points of disagreement or conﬂict, and repeatedly exchange feedback for modiﬁcation. Eventually, the preliminary layout becomes the deﬁnitive layout while the design sketch develops into the deﬁnitive exterior form. The outcome in this phase is the deﬁnitive layout reﬂecting the ﬁnal size of the product being designed.</span></p>
<p><span lang="en">第二階段（概念設計-E）：工程設計師根據產品規格快速制定初步佈局。他們通常使用以前開發的產品的數據。完成後，他們將初步佈局作為3D CAD數據發送給工業設計師。這是工業設計過程的起點。工業設計人員將其用作開發外觀的輸入，而工程設計人員則尋求系統性能的解決方案並繼續完善佈局。隨著內部佈局和外部形式的同時發展，兩個團隊密切互動並討論任何分歧或衝突之處，並反復交換反饋以進行修改。最終，當設計草圖發展為確定的外觀形式時，初步佈局成為確定的佈局。這個階段的結果是確定設計的最終佈局，從而確定最終產品的尺寸。</span></p>
<p><span>2.5th phase (Concept Design-I): This process is far from an independent subsequent phase but rather an intermediary phase between the second and the third. Thus, we shall call it the 2.5th phase. It starts upon the receipt of preliminary layout from engineering designers and progresses concurrently with Concept Design-E. The industrial designers check the interior layout and overlay with a matching exterior form. They undertake idea sketches, 3D CAD modelling, rendering, design evaluation meetings, and a mock-up selection event to decide on theexterior form design. Engineeringdesigners keep advisingand evaluating ontheexteriorform.Assuch,theexteriorformand layoutdeveloplittlebylittle through the intertwined Concept Design-I and Concept Design-E.</span></p>
<p><span><br/></span>2.5階段（概念設計-I）：此過程遠非一個獨立的後續階段，而是第二和第三階段之間的中間階段。因此，我們將其稱為第2.5階段。它從收到工程設計人員的初步佈局開始，並與Concept Design-E同時進行。工業設計師檢查內部佈局並以匹配的外部形式進行覆蓋。他們進行構想草圖，3D CAD建模，渲染，設計評估會議和模型選擇活動，以決定外觀設計。工程設計人員不斷為外觀設計提供建議和評估。因此，外觀設計和佈局通過相互交織的Concept Design-I和Concept Design-E逐步發展。</p>
<p><span>3rd phase (Detail designtesting and production/Follow-up): This phase is not markedly diﬀerent from that in Type 1 and Type 2.</span></p>
<p><span lang="en">第三階段（詳細設計測試和生產/跟進）：該階段與類型1和類型2沒有明顯不同。</span></p>
<p><span>All companies except Company B used this process. This indicates that it is most widely used. Interviewees noted that this process is comparable to the companies’ oﬃcial guidelines for design processes in terms of roles, tasks, and stages. However, they mentioned that the actual period is shorter than that speciﬁed in the guidelines.</span></p>
<p><span lang="en">除公司B以外的所有公司都使用此過程。這表明它被最廣泛地使用。受訪者指出，就角色，任務和階段而言，此過程可與公司有關設計過程的正式指導方針相媲美。但是，他們提到實際時間比指南中指定的時間短。</span></p>
<p><span>2.4 Type 4: ID&amp;ED Synergetic Process</span></p>
<p><span>Type 4 took place not by oﬃcial proposal but individual designers’ eﬀorts in the early phases. In many cases, engineering designers involved in developing line-up models tend to reject novel design concepts proposed by industrial designers, because of feasibility issues within the limited time. To implement the concepts, industrial designers work with engineering designers who are freer. Therefore, this process makes it possible to continue with novel design concepts that were rejected. In addition, industrial designers and engineering designers make synergic eﬀorts. Breaking away from the conventional separated approach, they handle a design concept in an integrated way considering many design variables concurrently. The detailed phases of this process are as follows):</span></p>
<p><span lang="en">2.4類型4：ID＆ED協同過程類型4並非是根據官方提議而發生的，而是各個設計師在早期階段的嘗試。在許多情況下，由於在有限的時間內存在可行性問題，參與開發陣容模型的工程設計師往往會拒絕工業設計師提出的新穎設計概念。為了實施這些概念，工業設計師與自由設計師合作。因此，此過程使繼續拒絕的新穎設計概念成為可能。此外，工業設計師和工程設計師也可以協同工作。與傳統的分離方法不同，它們以集成方式處理設計概念，同時考慮了許多設計變量。此過程的詳細階段如下）： </span></p>
<p>圖8:</p>
<p><img alt="" height="427" src="https://s40723221.github.io/cd2020/images/c9.png" width="386"/></p>
<p><span>1st phase (Concept Incubation): As in Figure 9, industrial designers conceive of a new design independently. They mostly build it from the design ideas that were excluded from proceeding projects despite their innovativeness.</span></p>
<p><span lang="en">第一階段（產生概念）：如圖9所示，工業設計師獨立地構思新設計。他們大都是根據僅有創新性但仍未開始進行的設計構想來構建它。</span></p>
<p><span lang="en"><span>2nd phase (Concept Design): This phase starts when industrial designers seek engineering designers who can work with them. When an engineering designer agrees to join the industrial designer for implementing the design concept, they work closely throughout this phase. The engineering designer provides stateof-the-art technology for the industrial designer to sharpen the design concept. The ﬁrst level of inside layout is developed based on the outer shape that is being developed. The outcomes of this phase are the 3D CAD data about the exterior form and interior layout.</span></span></p>
<p><span lang="en">第二階段（概念設計）：此階段始於工業設計師尋找可以與他們合作的工程設計師。當工程設計師同意加入工業設計師以實施設計概念時，他們將在整個階段中緊密合作。工程設計師為工業設計師提供最先進的技術，以增強設計理念。內部佈局的第一層是根據要開發的外部形狀開發的。該階段的結果是有關外觀和內部佈局的3D CAD數據。</span></p>
<p><span lang="en">3rd phase (Product Planning): Product planning team decides commercialization of the design via a design evaluation meeting. Then, the product planning team deﬁnes the target market for the design. From this phase, the engineering designers in charge of developing line-up models become involved.</span></p>
<p><span lang="en">第三階段（產品計劃）：產品計劃小組通過設計評估會議來決定設計的商業化。然後，產品計劃團隊確定設計的目標市場。從這個階段開始，負責開發陣容模型的工程設計人員就參與其中。4th phase (Detail designtesting &amp; production/Follow-up): The process of this phase is not much diﬀerent from that in Types 1, 2, and 3.第四階段（詳細設計測試和生產/跟進）：該階段的過程與類型1、2和3的過程沒有太大不同。</span></p>
<p><span lang="en"><span>The existing product development environment causes engineering designers to be conservative. Most development projects in the domain of consumer electronics are urgent. Companies usually set a product launch day in their plans. Thus, designers execute all tasks and events following the timeline to the day. Based on the interview data, engineering designers involved in these kinds of projects tend to reject novel design concepts proposed by industrial designers, because they feel that they could not ensure their work with the concepts pass the performance and reliability tests by the chosen time. The failure of the testing will directly inﬂuence the company’s product development roadmap as well as the engineering designer’s annual performance when evaluated. This seems to make them select and evaluate design concepts conservatively. Therefore, this process is hardly available to the designers who are directly involved in projects proceeding on a timeline to the market. Conversely, engineering designers who are relatively free from the timeline to the market, for example, those involved in developing advanced technology for future products will be more open to novel design concepts. Besides, more importantly it seems that designers who are more open-minded to collaborative works with other experts tend to execute this process.</span></span></p>
<p><span lang="en">現有的產品開發環境使工程設計人員趨於保守。消費電子領域的大多數開發項目都是緊迫的。公司通常會在計劃中設定產品發布日。因此，設計人員將按照時間軸執行所有任務和排程。根據訪談數據，參與此類項目的工程設計師傾向於拒絕工業設計師提出的新穎設計概念，因為他們認為自己無法確保使用這些概念的作品能夠在選定的時間通過性能和可靠性測試。測試失敗將直接影響公司的產品開發路線圖以及工程設計師評估時的年度績效。這似乎使他們保守地選擇和評估設計概念。因此，對於直接參與按時間表進入市場的項目的設計人員來說，幾乎無法使用此過程。相反，相對而言，從時間表到市場的時間相對有限的工程設計師，例如那些參與開發面向未來產品的先進技術的工程師，將更願意接受新穎的設計理念。此外，更重要的是，似乎更願意與其他專家合作進行設計的設計師傾向於執行此過程。</span></p>
<p><span lang="en">In the case of Company D, Type 4 had a great market success with a new product by employing this process. However, further cases actively applying this process to following projects were not reported in our interview. Nonetheless, it is interesting that Company D dispatched several engineering designers from the advanced technology development team to a neighbouring oﬃce of the industrial design team. This enabled the synergetic process case. The top management purposely moved them to prevent industrial designers producing unrealistic design concepts by letting them provide necessary technical supports promptly for industrial designers. This seems to stimulate both parties to be more intimate, thereby creating a cooperative mood. This will increase the possibility of emerging integrated design processes.</span></p>
<p><span lang="en">對於公司D，通過採用此過程，類型4在新產品方面取得了巨大的市場成功。但是，在我們的採訪中沒有報告更多將這一過程積極應用於後續項目的案例。儘管如此，有趣的是，D公司還是從先進技術開發團隊派遣了幾名工程設計師到工業設計團隊的一個相鄰辦事處。這啟用了協同處理案例。最高管理者故意讓他們動用，以使他們迅速為工業設計師提供必要的技術支持，以防止工業設計師提出不切實際的設計概念。這似乎激發了雙方更加親密，從而營造了合作的氣氛。這將增加新興的集成設計流程的可能性。</span></p>
<p><span lang="en">3 .Discussion and implication3.</span></p>
<p><span lang="en">討論與啟示</span></p>
<p><span>3.1 Role change</span></p>
<p><span><br/></span>3.1角色變更</p>
<p><span>Industrial designers’ contribution is dominant in the concept design phase and afterward, engineering designers take over their major role. This can be regarded as the general characteristics of the four types of design processes. With the exception of Type 3, all the design processes started with design concepts developed by industrial designers. In the case of Type 1 and Type 2, industrial designers independently deﬁne the design concept in terms of shape and use. Type 4 is integrative in the concept design phase, but starts with the industrial designer’s initial design concept. Unlike the other three types, Type 3 cases, where the scheduled modiﬁcation of existing products happens, start with the layout design by engineering designers. It appears that their roles are divided as concept developers and concept implementers. Interestingly, as a company pursues new concept products or emphasizes emotional feeling and usability even in re-design cases, the role of industrial designers seems to be signiﬁcant. This is a diﬀerent phenomenon from the idea that a new concept product is developed through the development of new principles and technology. They rather devised new uses or the meaning of existing ones. Therefore, this can be viewed as evidence that new design also starts with existing technologies and principles.</span></p>
<p><span lang="en">工業設計師的貢獻在概念設計階段占主導地位，此後，工程設計師接任其主要角色。這可以視為四種設計過程的一般特徵。除類型3外，所有設計過程均始於工業設計師開發的設計概念。對於類型1和類型2，工業設計師根據形狀和用途獨立定義設計概念。 Type 4在概念設計階段是集成的，但從工業設計師的初始設計概念開始。與其他三種類型（第3種情況）不同，在這種情況下，對現有產品進行了計劃中的修改，首先是由工程設計師進行佈局設計。看來他們的角色分為概念開發者和概念實現者。有趣的是，當一家公司追求新概念的產品或強調情感感覺和可用性（即使在重新設計案例中）時，工業設計師的作用似乎很重要。這與通過開發新原理和新技術來開發新概念產品的想法不同。他們寧願設計新用途或現有用途的含義。因此，這可以被視為新設計也從現有技術和原理開始的證據。</span></p>
<p><span>Regarding industrial designers’ knowledge, counter to our belief that they would rarely consider inside parts, they seem to have enough knowledge to read and handle the inside functional components and carry out the outside design. Except for Type 1, deﬁning the outside shape always happens through considering and rearranging the inside functional parts by industrial designers. Type 2 is an unexpected case. Industrial designers develop the outer shape by arranging the related inside components at the same time. However, their work on the inside parts was probably limited to major parts that directly aﬀect the outside shape. Although, they were not fully involved in designing the details of inside parts, it is apparent that their role was extended to the area of engineering design. It is attributed to the top management’s strong support to industrial design and the shared CAD tools between both groups.</span></p>
<p><span lang="en">關於工業設計師的知識，與我們認為很少考慮內部零件的信念相反，他們似乎具有足夠的知識來閱讀和處理內部功能組件並進行外部設計。除類型1外，定義外部形狀通常是通過工業設計師考慮並重新佈置內部功能部件來進行的。類型2是意外情況。工業設計師通過同時安排相關的內部組件來開發外形。但是，他們在內部零件上的工作可能僅限於直接影響外部形狀的主要零件。儘管他們沒有完全參與設計內部零件的細節，但是很明顯，他們的作用已擴展到工程設計領域。這要歸功於最高管理層對工業設計的大力支持以及兩組之間共享的CAD工具。</span></p>
<p><span>3.2 Selection of design approach</span></p>
<p><span lang="en">3.2選擇設計方法</span></p>
<p><span>Theoretically ‘inside-out’ and ‘outside-in’ approaches happen and are caused by the combination of diﬀerent working tendencies of engineering designers and industrial designers (Hubka &amp; Eder, 2012; Kim &amp; Lee, 2010). The four types of collaborative design processes can be seen as extended versions of the two approaches. This section discusses the relationship between the four types and the two approaches, conditions for applying each type successfully, and applying them in consultant and client partnership settings.</span></p>
<p><span lang="en">從理論上講，“由內而外”和“由外而內”的方法是發生的，並且是由工程設計師和工業設計師的不同工作傾向共同造成的（Hubka＆Eder，2012； Kim＆Lee，2010）。四種類型的協作設計過程可以看作是這兩種方法的擴展版本。本節討論四種類型與兩種方法之間的關係，以及成功應用每種類型並將其應用於顧問和客戶合作夥伴設置的條件。</span></p>
<p><span>For consumer products whose contexts of use are emphasized, industrial designers are supposed to ﬁrstly deﬁne the exterior in relation to usability and appearance, and then engineering designers decide the interior functional parts linked with the exterior to support the usability and appearance. This is an outside-in approach where Type 1 is suitable and Type 2 is nearly appropriate in such contexts. If we deﬁne inside-out process as deciding preliminary layout ﬁrst and then using it for developing the ensuing outside form and deﬁnitive layout together, Type 3 is a case. Considering the two approaches, Type 4 is considered as a mixed process, because both exterior and interior are deﬁned simultaneously. If we deﬁne inside-out process as deciding the exterior after completing interior deﬁnitive layout, there is no such process across the companies studied here. It is less suitable for use with consumer products. It is rather suitable for industrial durable goods. For example, if we design an industrial motor, the capacity determines the winding number of electric wires and the size of magnetic cores. We should calculate the layouts and sizes of interior rotors and stators scientiﬁcally to achieve optimal performance. Thus, the interior parts must be fully decided ﬁrst, and then the exterior form is deﬁned to overlay. If we develop the interior parts of a motor based on a pre-set exterior form, it will not operate properly.</span></p>
<p><span lang="en">對於強調使用環境的消費產品，工業設計師應首先定義與可用性和外觀有關的外觀，然後工程設計師確定與外部鏈接的內部功能部件以支持可用性和外觀。在這種情況下，這是一種由外而內的方法，其中類型1適用，類型2幾乎適用。如果我們將內向外過程定義為首先確定初步佈局，然後將其用於共同開發隨後的外部形式和確定性佈局，則類型3是一種情況。考慮到這兩種方法，類型4被視為混合過程，因為外部和內部都同時定義。如果我們將內部到外部的過程定義為在完成內部確定的佈局後決定外部的過程，則此處研究的公司中沒有這樣的過程。它不太適合與消費產品一起使用。它非常適合工業耐用品。例如，如果我們設計一台工業電動機，容量將決定電線的纏繞數和磁芯的尺寸。我們應該科學地計算內部轉子和定子的佈局和尺寸，以獲得最佳性能。因此，必須首先完全確定內部零件，然後將外部形式定義為覆蓋。如果我們根據預設的外部形式開發電機的內部零件，它將無法正常運行。</span></p>
<p><span>When using Type 1, industrial designers can come up with innovative design ideas freely. Nevertheless, the approach will lead to two problems. First, it will be diﬃcult to gain technological performance in engineering. To achieve optimal performance, the internal functional parts may clash with the exterior shape. Second, to solve the ﬁrst problem the design team is likely to compromise the original design concept through trading oﬀ between functions and appearance. To manage this approach successfully, top management’s strong support to keep the innovativeness of the design will be necessary when a compromise is to take place. Type 2 could be an alternative solution to the problems as we observed in Company B. Its strategy was that industrial designers decide the exterior form while moving or placing the related interior parts. This avoids critical interference between exterior and interior parts. Yet, it is arguable whether industrial designers should execute the interior layout design in addition to the exterior form development at the expense of the freedom of imagination. It is probable that they compromise innovativeness within their knowledge. To apply Type 2 successfully, designers should be highly knowledgeable about both industrial design and engineering design.</span></p>
<p><span lang="en">使用Type 1時，工業設計師可以自由提出創新的設計思路。然而，該方法將導致兩個問題。首先，很難獲得工程技術性能。為了獲得最佳性能，內部功能部件可能會與外形衝突。其次，為了解決第一個問題，設計團隊可能會通過在功能和外觀之間進行權衡來折衷原始設計概念。為了成功管理此方法，當折衷方案發生時，高層管理人員必須保持強大的支持以保持設計的創新性。正如我們在B公司中觀察到的那樣，類型2可以替代這些問題。它的策略是，工業設計師在移動或放置相關內部零件時確定外觀形式。這避免了內部和外部之間的嚴重干擾。然而，有爭議的是，工業設計師是否應在外觀設計開發之外還進行室內佈局設計，以犧牲想像力為代價。他們可能會在自己的知識範圍內折衷創新。要成功應用Type 2，設計師應該對工業設計和工程設計都具有很高的知識。</span></p>
<p><span>To attain the feasibility of a superior design concept in the early phase, Type 4 is worth noting as industrial designers’ concepts and engineering designers’ technical support enable new product development. Given this process is eﬃcient and likely to develop innovative products, companies need for it proper conditions to employ. Dyson Company can be a role model. It is known that designers and engineers share a workspace as members of a department for the integrated implementation of design (Dyson &amp; Coren, 1997). To facilitate this process, companies need to have an integrated team where two groups share a working space and absorb each discipline’s culture as expected. More important is the organizational culture that stimulates designers to be challenging and open to work together. If designers are worried about company’s penalty for a failure, they will be more conservative. Without this situational change, Type 4 even as a well-documented process in a company will not eﬀectively work.</span></p>
<p><span lang="en">為了在早期階段獲得高級設計概念的可行性，值得注意的是Type 4，因為工業設計師的概念和工程設計師的技術支持可以開發新產品。鑑於此過程非常有效並且有可能開發創新產品，因此公司需要為其提供適當的使用條件。戴森公司可以成為榜樣。眾所周知，設計師和工程師作為一個部門的成員共享一個工作區，以實現設計的集成實施（Dyson＆Coren，1997）。為了促進此過程，公司需要有一個集成的團隊，其中兩個小組共享一個工作空間，並按預期吸收每個學科的文化。更為重要的是組織文化，它激發了設計師挑戰性和開放性，可以一起工作。如果設計師擔心公司因失敗而受到懲罰，那麼他們會更加保守。沒有這種情況的改變，類型4甚至作為公司中有據可查的流程都將無法有效地發揮作用。</span></p>
<p><span>In industry, many engineering companies collaborate with external industrial designers. Although, we did not investigate this type of collaboration, discussion about possible process scenarios in reference to our ﬁndings will be beneﬁcial. When manufacturers work with design consulting ﬁrms, they can receive complementary support to complete the project on time or generate fresh ideas (Bruce &amp; Morris, 1994). In consultant and client partnerships, there are two modes of process couplings: passive coupling where consultants develop solutions independently while they contact the client to get additional information or review their outcomes, and active coupling where the collaborative team of consultants and clients designers work closely to generate solution (Gericke &amp; Maier, 2011). In passive coupling, as the external designers work independently, its design process will be similar to Type 1 or 2. Type 1 will be useful when clients want to collect creative ideas as many as possible by utilizing the speciﬁc specialities they missing. This case will be helpful when client companies are highly technology-oriented and have enough capability to implement good concepts with strong engineering supports. Type 2 will be appropriate when clients have less capability than in the above-mentioned case and are required to utilize external industrial designers to lead their product development at the initial stage. The active coupling mode will have similar processes to Type 3 and 4. Type 3 will be appropriate when clients already have good design direction and related technology, and want to improve the aesthetic appearance of the product. Type 4 will be reasonably impossible unless the integrated team of client and consultant companies work in the same space during project time. There should be other factors to consider in collaborative design processes in consultant and client partnership. In many cases, information provided by clients for consultants is restricted to some extent. Therefore, the same types of collaborative processes happening in a consultant and client partnership and inside of a company will not be the same in terms of contents. Nevertheless, our research results and discussion could provide clues for selecting a better design approach in the consumer electronics domain.</span></p>
<p><span lang="en">在行業中，許多工程公司與外部工業設計師合作。儘管我們沒有調查這種類型的協作，但是，根據我們的發現對可能的流程方案進行討論將是有益的。當製造商與設計諮詢公司合作時，他們可以得到補充支持，以按時完成項目或產生新的想法（Bruce＆Morris，1994）。在顧問和客戶合作關係中，有兩種過程耦合方式：被動耦合，其中顧問在與客戶聯繫以獲取更多信息或查看其結果時獨立開發解決方案，以及主動耦合，其中顧問和客戶設計師的協作團隊密切合作生成解決方案（Gericke＆Maier，2011年）。在被動耦合中，由於外部設計師獨立工作，其設計過程將類似於類型1或類型2。當客戶希望利用他們缺少的特定專業來收集盡可能多的創意時，類型1將非常有用。當客戶公司高度以技術為導向並且有足夠的能力在強大的工程支持下實施好的概念時，這種情況將很有幫助。如果客戶的能力比上述情況要小，並且在初期需要聘請外部工業設計師來領導其產品開發，則類型2將是合適的。主動耦合模式將具有與類型3和類型4相似的過程。當客戶已經具有良好的設計方向和相關技術，並且想要改善產品的美學外觀時，類型3將是合適的。除非客戶和顧問公司的整合團隊在項目期間在同一空間工作，否則第4類將是不可能的。在顧問和客戶合作夥伴的協作設計過程中應該考慮其他因素。在許多情況下，客戶為顧問提供的信息在一定程度上受到限制。因此，在顧問和客戶合作夥伴以及公司內部發生的相同類型的協作過程在內容方面將是不同的。儘管如此，我們的研究結果和討論仍可為在消費電子領域選擇更好的設計方法提供線索。</span></p>
<p><span>3.3 Implication of the types of design processes</span></p>
<p><span lang="en">3.3設計過程類型的含義</span></p>
<p><span>Industrial designers and engineering designers are diﬀerent in their design approaches, and perspectives about product development (Eder, 2013; Pahl et al., 2007; Ulrich &amp; Eppinger, 2012). Industrial designers generate usercentred solution concepts, and engineering designers solve design problems based on technical perspectives. The process exposed to these two groups’ specialities can be the basis for developing competitive and innovative products. Moreover, the coupling process of systematic engineering design and usercentred design thinking is beneﬁcial for generating user-centred solutions in consultanteclient relationships (Gericke &amp; Maier, 2011). The coupling process is the best option for a company to take, and achieve competitiveness in the market. For example, consumer electronics companies use the four types of collaborative design processes to achieve their market goals. Industrial designers’ role in the early phase of the four types is noticeable and the way of adopting industrial designers’ specialities is an inﬂuential factor in adopting an appropriate type of collaborative design process. The possibility of obtaining innovative design concepts can be increased by giving freedom to industrial designers as in Type 1. Then, how can such freedom drive industrial designers to create innovative design concepts? In fact, architectural and industrial designers start with the solution image ﬁrstly and ﬁnalize by following repetitive trials (Lawson, 2006; Roozenburg &amp; Cross, 1991). This is consistent with a model where designers ﬁrstly engage in conjecture based on presuppositions and then perform analysis (Hillier et al., 1972). It implies that industrial designers rely on envisioning the future to create innovative concepts rather than thick design research about market and customers. Press and Cooper (2003) added that industrial design approach is value-driven. Therefore, industrial designers in Type 1 are given freedom from constraints to generate creative ideas through envisioning the desired future.</span></p>
<p><span lang="en">工業設計師和工程設計師在設計方法和關於產品開發的觀點上是不同的（Eder，2013； Pahl等，2007； Ulrich＆Eppinger，2012）。工業設計師產生以用戶為中心的解決方案概念，工程設計師根據技術角度解決設計問題。這兩個群體的專業所面臨的過程可能是開發具有競爭力的創新產品的基礎。此外，系統工程設計和以用戶為中心的設計思想的耦合過程對於在顧問與客戶之間的關係中生成以用戶為中心的解決方案是有益的（Gericke＆Maier，2011）。耦合過程是公司採取並實現市場競爭力的最佳選擇。例如，消費電子公司使用四種類型的協作設計過程來實現其市場目標。工業設計師在這四種類型的早期階段中的作用是顯而易見的，採用工業設計師專業的方式是採用適當類型的協作設計過程的重要因素。通過給予類型1中的工業設計師自由，可以增加獲得創新設計概念的可能性。那麼，這種自由如何驅動工業設計師創建創新設計概念呢？實際上，建築和工業設計師首先從解決方案的圖像入手，然後通過重複試驗最終確定（Lawson，2006； Roozenburg＆Cross，1991）。這與一個模型有關，在該模型中，設計人員首先基於預設進行推測，然後進行分析（Hillier等，1972）。這意味著工業設計師依靠對未來的展望來創造創新的概念，而不是對市場和客戶進行深入的設計研究。 Press and Cooper（2003）補充說，工業設計方法是價值驅動的。因此，類型1的工業設計師可以不受約束，可以通過設想所需的未來產生創意。</span></p>
<p><span lang="en">Norman and Verganti (2014) argued that innovative product development takes place with technology or meaning change rather than serious design research with human-centred approach. They added that human-centred design methods are more suitable for the incremental improvement of existing</span></p>
<p><span>products. In the current product development environment in the consumer electronics domain, product-planning experts play a pivotal role in research on market and customers. Thus, the input from the product planning team to industrial designers will be restricted to their creativity. This explains why companies utilize Type 1 in a reverse way; developing concepts ﬁrst and then deﬁning the market next rather than the other way around. Typically in product design concept, designers consider function concept that is highly related to technology, and styling concepts that give new meaning to the users (Baxter, 1995). Thus, the design concept produced by industrial designers should be innovative, because of the function and/or styling concepts. When it relates to the technology, engineering designers should develop new technologies or search appropriate technologies to implement the concept. This type of process can lead to new technology development if not rejected in the product development planning stage.</span></p>
<p><span lang="en">Norman和Verganti（2014）認為，創新產品開發是通過技術或含義的改變進行的，而不是以人為中心的認真的設計研究。他們補充說，以人為本的設計方法更適合於現有產品的逐步改進產品。在消費電子領域當前的產品開發環境中，產品規劃專家在市場和客戶研究中起著關鍵作用。因此，產品規劃團隊對工業設計師的投入將僅限於他們的創造力。這解釋了為什麼公司以相反的方式使用Type 1；首先開發概念，然後再定義市場，而不是相反。通常，在產品設計概念中，設計師會考慮與技術高度相關的功能概念，以及會給用戶帶來新含義的樣式概念（Baxter，1995年）。因此，由於功能和/或樣式概念，工業設計師提出的設計概念應該是創新的。當涉及到技術時，工程設計師應開發新技術或尋找適當的技術來實施該概念。如果在產品開發計劃階段沒有被拒絕，這種類型的過程會導致新技術的開發。</span></p>
<p><span>In Type 2, the company imposes various roles and responsibilities on industrial designers. As engineering designers do not interrupt, they may have a certain level of freedom. Industrial designers’ approach is solution-oriented. They do not usually follow systematic process. They rather come up with new ideas and repeated them. However, Type 2 probably interrupts industrial designers approach by imposing another role in which they handle inside layout design with the exterior design. Industrial designers adopting problem oriented and systematic approaches will deﬁnitely restrict them from imagination in concept development. This will make them more realistic when considering the feasibility of their design concepts. As such, the design outcome of Type 2 will be less innovative than that of Type 1. Otherwise, Type 2 will be better ﬁt for redesign than new design. If industrial designers do not consider the inside parts in Type 2 for redesign, they can face diﬃculties, and the design concept can be rejected (Kim &amp; Lee, 2014).</span></p>
<p><span lang="en">在類型2中，公司對工業設計師承擔各種角色和職責。由於工程設計師不會打擾他們，所以他們可能有一定的自由度。工業設計師的方法是面向解決方案的。他們通常不遵循系統的過程。他們寧願提出新的想法並重複他們。但是，類型2可能通過強加他們在內部佈局設計和外部設計中扮演的另一角色而中斷了工業設計師的方法。工業設計師採用面向問題和系統的方法，將最終限制他們在概念開發中的想像力。在考慮其設計概念的可行性時，這將使它們更加現實。因此，類型2的設計結果將不如類型1的創新。否則，類型2將比新設計更適合重新設計。如果工業設計師不考慮將Type 2的內部零件進行重新設計，則他們可能會面臨困難，設計概念可能會被拒絕（Kim＆Lee，2014）。</span></p>
<p><span>If we consider applying Type 2 and Type 3 for redesign, when does Type 2 better than Type 3? The characteristics of Type 3 are in accordance with most design processes shown in engineering design. Industrial design has been considered as an afterthought in the engineering design ﬁeld (e.g. Andreasen &amp; Hein, 2000; Hubka &amp; Eder, 1987; Pahl et al., 2007). As per their viewpoints, industrial design’s function is related to the aspects of product appearance, such as styling, form and colour after a product’s technical features are determined. Type 3 is the process where engineering designers have technological solutions to the design concept. They request industrial designers to develop exterior appearance. Thus, Type 3 uses only part of industrial designers’ expertise in creating aesthetic appearance. In this perspective, Type 2 can oﬀer more ways for industrial designers to show their expertise than Type 3. Considering the fact that Type 3 is the most frequently used process, it can be more eﬃcient in terms of process management. Probably, the uncertainty in the early phase in Type 3 is the least among the four types. Most of the technical solutions for</span></p>
<p><span>the design concept are set by engineering designers in the early phase, and industrial designers are only limited to create aesthetic appearance.</span></p>
<p><span lang="en">如果我們考慮將類型2和類型3用於重新設計，那麼類型2何時比類型3更好？類型3的特性符合工程設計中顯示的大多數設計過程。工業設計被認為是工程設計領域中的事後想法（例如Andreasen＆Hein，2000； Hubka＆Eder，1987； Pahl等，2007）。按照他們的觀點，工業設計的功能與產品外觀的各個方面有關，例如確定產品的技術特徵後的樣式，形式和顏色。第3類是工程設計師為設計概念提供技術解決方案的過程。他們要求工業設計師開發外觀。因此，類型3僅使用工業設計師的部分專業知識來創造美學外觀。從這個角度來看，類型2比類型3可以為工業設計師提供更多的方法來展示其專業知識。考慮到類型3是最常用的過程，因此在過程管理方面可以更有效。類型3早期階段的不確定性可能是四種類型中最小的。的大多數技術解決方案設計概念是由工程設計師在早期階段設定的，而工業設計師只限於創造美學外觀。</span></p>
<p><span>The one process we could not discover would be Type 5: ED-led Technologydriven process. This could be contrasted to Type 1: ID-led Concept-driven Process. In Type 5, engineering designers would develop a new technology at ﬁrst without consideration product development plan, and test its performance with testing prototypes. Next, industrial designers generate new product design concepts for the technology. Then, the visualized design concepts and the prototypes could be used to decide product development. Applying Type 5, a company could create a new category product that increases the possibility to open a new market. One of the reasons that we could not ﬁnd this type would be the rareness of innovative technology development, and a rare chance for new technology to meet a new concept. In addition, a company is unlikely to wait for engineering designers and industrial designers with great uncertainty until the product development is decided. To make this process better, we need engineering designers to develop new technologies, and industrial designers to create new concepts using technology with mutual cooperation. From this argument, Type 4 can be useful in applying oﬃcially for innovative product design. It can also enable the technology developed by engineering designers to be integrated with new concepts generated by industrial designers.</span></p>
<p><span lang="en">我們找不到的一個過程是類型5：ED主導的技術驅動過程。這可以與類型1：由ID主導的概念驅動過程形成對比。在類型5中，工程設計人員將首先開發一項新技術而無需考慮產品開發計劃，並使用測試原型來測試其性能。接下來，工業設計師為該技術產生新的產品設計概念。然後，可視化的設計概念和原型可用於決定產品開發。應用類型5，公司可以創建新類別的產品，從而增加打開新市場的可能性。我們無法找到這種類型的原因之一是創新技術開發的稀缺性，以及新技術滿足新概念的難得機會。另外，在決定產品開發之前，公司不太可能等不確定的工程設計師和工業設計師。為了使此過程更好，我們需要工程設計師開發新技術，需要工業設計師使用相互合作的技術創建新概念。根據這一論點，類型4在正式用於創新產品設計時會很有用。它還可以使工程設計師開發的技術與工業設計師提出的新概念集成在一起。</span></p>
<p><span>4 .Conclusion</span></p>
<p><span><br/></span>4.結論</p>
<p><span>We aimed to determine the existence of the types of collaborative design processes, and the conditions of adopting a particular type in a company. We established collaborative design processes from in-depth interview data of industrial designers and engineering designers. As a result, we found four types of collaborative design processes. They were categorized according to the difference of the early phases of the design process. The four types of processes are used for diﬀerent purposes in diﬀerent contexts. At times, they are applied strategically to develop new design or redesign, and at other times they are applied organically due to internal and external forces. We also found that the role of industrial designers is inﬂuential and extended.</span></p>
<p><span lang="en">我們旨在確定協作設計過程類型的存在以及在公司中採用特定類型的條件。我們根據工業設計師和工程設計師的深入訪談數據建立了協作設計流程。結果，我們發現了四種類型的協作設計過程。根據設計過程早期階段的不同對它們進行分類。四種類型的過程在不同的上下文中用於不同的目的。有時，它們會被戰略性地用於開發新設計或重新設計，有時它們會由於內部和外部因素而有機地應用。我們還發現，工業設計師的作用是有影響力的，而且是擴展的。</span></p>
<p><span>The abstract character of design process models and the mono-disciplinary approaches in research are not well-matched to actual practice and are identiﬁed as the causes of this problematic situation (Brooks Jr, 2010; Eckert &amp; Clarkson, 2005). In this regard, there has been a request to combine diﬀerent design process models (Albers, 2010; Dorst, 2008). The four types of processes are combined processes of a solution-oriented approach driven by industrial designers and a problem-oriented approach by engineering designers. They show the actual design process is not represented with a single model even in a single domain, i.e. consumer electronics. To improve the applicability of design processes and to receive the suitable support of design methodologies in design practice, more concrete process models that consider the speciﬁc context of a company and project are needed (Finkelstein &amp; Finkelstein, 1983; Gericke &amp; Blessing, 2011). We speciﬁcally focused on the consumer electronics domain where industrial designers and engineering designers importantly collaborate in product development. We found the four types of design processes and identiﬁed their purposes and contexts. Thus, our ﬁndings with the contextual detail will provide useful information for companies planning eﬃcient design process management for new product development, especially in the consumer electronics domain.</span></p>
<p><span lang="en">設計過程模型的抽象特徵和研究中的一門學科方法與實際實踐並不完全匹配，並且被確定為造成這種問題情況的原因（Brooks Jr，2010； Eckert＆Clarkson，2005）。在這方面，有人要求結合不同的設計過程模型（Albers，2010； Dorst，2008）。四種類型的過程是工業設計師驅動的以解決方案為導向的方法和工程設計師以問題為導向的方法的組合過程。它們表明，即使在單個領域（即消費類電子產品）中，實際的設計過程也無法用單個模型來表示。為了提高設計過程的適用性並在設計實踐中獲得設計方法的適當支持，需要考慮公司和項目具體環境的更為具體的過程模型（Finkelstein＆Finkelstein，1983； Gericke＆Blessing，2011）。我們特別專注於消費電子領域，在這一領域中，工業設計師和工程設計師在產品開發中起著重要的合作作用。我們發現了四種類型的設計過程，並確定了它們的目的和背景。因此，我們發現的有關上下文的詳細信息將為公司計劃針對新產品開發的有效設計過程管理提供有用的信息，尤其是在消費電子領域。</span></p>
<p><span>In light of the research methodology, we have shown how collaborative design processes can be established from in-depth interview data of designers. We identiﬁed process elements, constructed partial processes with them, and built detailed collaborative design processes with our mosaic method. We also introduced ‘process chunk’ and deﬁned a chunk or two interacting chunks as a phase. We argue that this approach is beneﬁcial to determine actual design process at best level. We think this method is applicable to the discovery of other design processes. The form of our process models is comparable to other phase-based models (e.g. French, 1998; Pahl et al., 2007). We found from our models that reverse iteration or feedback rarely happens between phases. This is diﬀerent from the description of existing phase-based engineering design process models. In an ideal situation, we think bidirectional iteration is possible, but practically because of severe market competition, we conclude that it seldom happens.</span></p>
<p><span lang="en">根據研究方法，我們展示瞭如何從設計師的深入訪談數據中建立協作設計過程。我們確定了過程元素，並使用它們構造了部分過程，並使用鑲嵌方法建立了詳細的協作設計過程。我們還引入了“過程塊”，並定義了一個或兩個交互塊作為一個階段。我們認為這種方法有利於確定最佳水平的實際設計過程。我們認為該方法適用於發現其他設計過程。我們的過程模型的形式可與其他基於階段的模型相比較（例如French，1998； Pahl等，2007）。我們從模型中發現，在階段之間很少發生反向迭代或反饋。這與現有的基於階段的工程設計過程模型的描述不同。在理想情況下，我們認為雙向迭代是可能的，但是實際上由於激烈的市場競爭，我們認為這種情況很少發生。</span></p>
<p><span>Further studies with this method are required especially toward other project cases in other product domains. The companies in this study were all manufacturers of electronic products. Therefore, the result is limited to this product category. We need to test how the four collaborative design processes are applied in other companies. Conversely, it is worth studying cases of innovative product development and the processes applied.</span></p>
<p><span lang="en">特別是針對其他產品領域中的其他項目案例，需要對該方法進行進一步的研究。本研究中的公司均為電子產品製造商。因此，結果僅限於此產品類別。我們需要測試這四個協作設計過程如何在其他公司中應用。相反，值得研究創新產品開發和應用過程的案例。</span></p>
<h3>DigitalProductCollaboration</h3>
<p><span class="fontstyle1">設計協調性更好的產品</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Create a Better Product With Design Collaboration — Mindset, Tools, Process</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">透過設計協調創作更好的場品<span> </span></span><span class="fontstyle0">—<span> </span></span><span class="fontstyle1">心態、工具、過程</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Digital products are more complex today than ever before. Creating them requires<br/>multiple team members, each with their own set of skills and expertise. At Savvy, for<br/>example, our customers work closely with: a product manager, UX designer, visual<br/>designer, developer(s), content strategist, and a growth specialist.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">現今的數位產品比以往都還要複雜。創建他們需要更多的團隊。每位成員都需<br/>要擁有自己的技藝與專業知識。例如<span> </span></span><span class="fontstyle0">Savvy</span><span class="fontstyle1">，我們的顧客。需要與產品經理、<br/></span><span class="fontstyle0">UX<span> </span></span><span class="fontstyle1">設計師、視覺設計師、開發人員、內容策略師還有增長專家密切配合。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>We use design collaboration to handle this complexity. Done right, design</span><br/><span>collaboration empowers each of those experts with the mindset, process, and tools</span><br/><span>to come together and build a better product faster.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">我們藉由設計協同來處理這種複雜性。正確的設計協同可以讓每一位專家擁有<br/>思維、流程和工具來快速的建立更好的產品。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>We wrote this resource to help other app creators adopt a collaboration culture and</span><br/><span>process. Read on to learn why design collaboration is important for creating</span><br/><span>compelling products and experiences. We'll also dive into the elements of a design</span><br/><span>collaboration mindset and culture, tools for effective design collaboration, and a</span><br/><span>real-world example of design collaboration at work.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">我們撰寫這篇資源是為了幫助其他<span> </span></span><span class="fontstyle0">APP<span> </span></span><span class="fontstyle1">創作者採用文化偕同和流程。深入閱讀<br/>了解為何設計協同對於創作引人注目的產品和體驗來說非常重要</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">What is "Design" Collaboration?</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">什麼是</span><span class="fontstyle0">”</span><span class="fontstyle1">設計</span><span class="fontstyle0">”</span><span class="fontstyle1">協同</span><span class="fontstyle0">?</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle0">Before we jump into it, we need to get on the same page about what design<br/>collaboration is... and is not. At its simplest, design collaboration is collaboration in a<br/>design-first environment. But, because of the nature of design, especially the design<br/>we do at Savvy, design collaboration tends to go beyond what people normally think<br/>of as collaboration.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">在直接跳入主題前，我們需要了解什麼是設計協同</span><span class="fontstyle0">…</span><span class="fontstyle1">什麼不是。簡單來說，設<br/>計協同就是在以設計為主的環境中進行協同合作。但是，因為設計的本質，特<br/>別是在與<span> </span></span><span class="fontstyle0">Savvy<span> </span></span><span class="fontstyle1">合作的設計之中，設計協同往往會超出人們一般認為的合作範</span><br/><span class="fontstyle1">圍。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">While collaboration is generally defined as two or more people working together on<br/>the same task towards a common goal, design collaboration involves much more.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">協同一般被定義為兩個或更多的人一起為同樣的目標工作，然而設計協同所涉<br/>及的東西卻更多。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Design collaboration includes more people with different skillsets, tougher<br/>challenges, and bigger goals with farther-reaching impacts.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">設計協同包括了更多具有不同技能的人、更艱困的挑戰、更大的目標並產生更<br/>深遠的影響</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>You might think of collaboration as two people hanging a piece of art. It simply</span><br/><span>requires communication, teamwork, and four hands. Design collaboration is when a</span><br/><span>team of curators carefully design a visitor's experience. They select the art, choose</span><br/><span>where and how to hang it, which room it lives in (and the room's lighting, furniture),</span><br/><span>even the preceding rooms and the building as a whole.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">你可能會認為協同就是兩個人懸掛一件藝術品，只需要溝通、團隊工作、和四<br/>隻手而已。設計合作是指由策劃團隊精心為參觀者設計的體驗，他們挑取藝術<br/>品並挑選掛在什麼地方、如何掛、掛在哪個房間</span><span class="fontstyle0">(</span><span class="fontstyle1">以及房間的燈光和家具</span><span class="fontstyle0">)<span> </span></span><span class="fontstyle1">，甚<br/>至是前一個房間和整棟建築物。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Why Design Collaboration is Important?</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">為什麼設計協同是重要的?</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">You can design a product without collaboration, but it takes a collaborative design<br/>process to make that product great. That's why design collaboration is so<br/>fundamental.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">你可以在沒有協同的情況下設計出一件產品，但透過一個合作的設計過程可以<br/>讓產品變的更加優秀，這就是為什麼設計協同是如此的重要。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>We don't just build apps for our customers. Savvy builds multi-platform experiences,</span><br/><span>complex internal systems, and in some cases, entire brands and businesses. To do so,</span><br/><span>we leverage expertise across several core disciplines: strategy, design, development,</span><br/><span>and growth. Each project involves many people, each with their own skillsets and</span><br/><span>specialties.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">我們並不只是為顧客構建應用程式，<span> </span></span><span class="fontstyle0">Savvy<span> </span></span><span class="fontstyle1">構建了多平台體驗、複雜的內部系<br/>統，並且在某些情況下，還可以構建整個品牌與業務，為此我們在戰略、設<br/>計、開發和成長等領域利用核心專業技術，每個項目都有許多人參加，每個人<br/>都有自己的技藝與專長。</span></p>
<p><br/><span class="fontstyle0">Design collaboration puts those minds together, combining their separate,<br/>specialized expertise to create solutions that tackle all aspects of a shared goal.<br/>Instead of coming at a problem from one angle, design collaboration places that<br/>problem in front of all experts, forcing them to consider new perspectives and<br/>possibilities.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">設計協同將這些人的思想概念結合在一起，將他們獨自的專業知識結合起來，<br/>創造出能夠解決共同目標所有方面問題的方案。設計協同不是從一個角度來解<br/>決一個問題，而是將所有問題放在專家面前，迫使他們考慮新的觀點與可能<br/>性。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">For example, we involve our developers early on in the design process to make sure<br/>we're accounting for technical opportunities and limitations as soon as possible. This<br/>allows us to take advantage of and push our technical capabilities while eliminating<br/>costly roadblocks further in the process. It also limits how much a single person can<br/>work in a silo, keeping the work in the open and the emphasis on the user needs and<br/>product goals.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">例如，我們在早期的設計過程就讓開發人員參與進來，確保盡快解決技術問題<br/>與侷限性。這使我們能夠利用在推動技術能力過程時，進一步消除昂貴的路<br/>障。這也同時限制一個人在總體的工作量，保持工廠的開放性，將重點放在用<br/>戶需求與產品目標上。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Cultivating a Design Collaboration Mindset</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">培養設計協同的心態</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">The right mindset goes a long way in establishing effective collaboration in the<br/>design process. It lays the guidelines for who collaborates, how, and to what end.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">正確的心態能幫助在設計過程中建立有效的合作關係，它為由誰來合作、如何<br/>合作以及合作的目的制定了準則。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">COLLABORATION IS FOR EVERYONE</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">協同是人人都可以的。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Designers sometimes think that people who are not designers are not qualified to<br/>give good feedback. But great design is more than visuals. It encompasses everything<br/>about a product, from its branding to its engineering to its growth.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">設計師有時候會認為不是設計師的人是沒有資格給出好的反饋的。但是，好的<br/>設計是不僅僅有視覺效果而已的，它包含了一個產品的一切，從品牌到工程再<br/>到在到期發展的一切。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Design collaboration brings in many people, each with their own perspectives and</span><br/><span class="fontstyle0">strengths. It gives everyone a voice. These fresh perspectives give designers more<br/>information. Perspectives equip designers to make the right decisions on choices<br/>that have lasting impacts on other design, development, and marketing options<br/>down the road.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">設計協同引進了許多人，每個人都有其自己的觀點與優勢，它使每個人都可以<br/>擁有發言權，這些創新的視角給了設計師更多的信息。觀點可以讓設計師能夠<br/>做出正確的決定，這些選擇會對以後的設計、開發與營銷產生持久的引響。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Collaboration with customers is as important as collaboration with other designers</span><br/><span>and team members. At Savvy, we keep our customer involved throughout the</span><br/><span>creation of their product. We take our time to explain options and have discussions</span><br/><span>with the customer to make sure we understand their thoughts.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">與客戶的合作和與其他設計師、團隊成員的合作同樣重要。在與<span> </span></span><span class="fontstyle0">Savvy<span> </span></span><span class="fontstyle1">的合作<br/>中，我們讓客戶參予產品的製作過程，並花時間解釋所選方案，與客戶進行討<br/>論，以確保我們了解他們的想法。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>This enables us to get buy-in from customers early on and work from clear</span><br/><span>beginnings and ends. Larger reveals aren't big surprises, and no one gets to the point</span><br/><span>where they're seeing work for the first time.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">這樣一來，我們就可以確保客戶的買帳並使工作有始有終，較大的揭露並不是<br/>什麼太大的驚喜，沒有人會因為第一次看到工作而感到驚訝。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Customer collaboration means arriving at a more defined product sooner, without<br/>costly back-stepping and unnecessary meetings.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">客戶的合作意味著更早產生一個確定的產品，避免了昂貴的迴避與不必要的會<br/>議。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">It's easy to get caught up in your role and ignore the big picture. By involving more<br/>people earlier on, you're fostering closer connections with teammates and<br/>cultivating a shared responsibility and interest in the success of the product. You're<br/>creating a more open and transparent process, as well a more connected and<br/>invested team.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">人們很容易沉浸在自己所扮演的角色中而忽略了大局觀，透過讓更多的人在早<br/>期參與進來，就能將團隊成員之間的聯繫培養的更緊密，並培養出責任感與對<br/>產品是否能成功的興趣。你正在創造一個更開放、更透明的過程，以及一個更<br/>有聯繫和投入的團體。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">COLLABORATION IS CONTEXTUAL</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">協同是有背景的</span></p>
<p><br/><span class="fontstyle0"><span>Customers come to us with complex challenges and goals. Not to mention, we</span><br/><span>continue to work with our customers for months, even years, and accumulate vast</span><br/><span>tomes of knowledge on past decisions, research, and other valuable context.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">客戶帶著複雜的挑戰與目標來尋找我們。更別提我們會持續與客戶合作數月甚<br/>至數年，累積了大量的知識，包含過去的決策、研究等其他有價值的背景。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">By adopting a context-first approach, you can make sure everyone is at the highest<br/>level of knowledge. This enables them to make the most informed decisions as they<br/>work on the product. To accomplish this, we keep everyone at Savvy updated on<br/>relevant information by bringing in all team members early, documenting and<br/>recording meetings, establishing some overlap, and treating the next team member<br/>in the process like a customer.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">透過適者生存的方法，確保每個人都處於最高的知識水平。使他們能夠在開發<br/>產品的過程中能夠做出最明確的決定，為了能夠做到這一點，我們透過提前召<br/>集所有團隊成員，紀錄和紀錄會議的內容，建立一些重和點，並將下一個團隊<br/>成員視為顧客，讓<span> </span></span><span class="fontstyle0">Savvy<span> </span></span><span class="fontstyle1">團隊的每一個人都能及時了解相關資訊。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Context is just as important on a case-by-case collaborative basis. Follow these</span><br/><span>guidelines to keep context first in collaboration:</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">在個案合作的基礎上，情境同樣重要，遵循這些準則，在合作中要把情境放在<br/>首位。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Provide context before showing your work. Chances are if your work is on the screen<br/>while you're giving context, you've lost your audience's attention.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">在顯示您的工作之前提供上下文。在提供背景信息的情況下，如果您的作品出<br/>現在屏幕上，那麼您可能會失去聽眾的注意力。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Describe the problem you're trying to solve or goal you're trying to achieve.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">描述您要解決的問題或要達到的目標。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Present your work as it relates to the problem at hand. Explain your thinking and<br/>why you made certain decisions.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">介紹與當前問題相關的工作。說明您的想法以及做出某些決定的原因。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Be specific about what you want feedback on.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">請具體說明您要反饋的內容。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">COLLABORATION IS OPEN, HONEST, AND FEARLESS</span></p>
<p><br/><span class="fontstyle1">合作是開放，誠實和無畏的</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">It isn't easy to put your work (and yourself) out there. Emotions can get in the way of<br/>providing open and honest feedback, especially when you're worried about hurting<br/>the other person's feelings.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">將您的工作（和您自己）放在那裡並不容易。情緒會阻礙您提供坦誠的反饋，<br/>尤其是當您擔心會傷害對方的感受時。</span></p>
<p><span class="fontstyle1"><br/></span><span><span class="fontstyle0">That doesn't mean there's no place for em</span><span class="fontstyle0">otion in collaboration. How something<br/>makes you feel is important in design. We think of and create solutions for people...<br/>people who are emotional, and who use emotions in their decisions. Leaving<br/>emotion out of the conversation might short-change a potential idea or solution. At<br/>best, having only a pragmatic discussion around facts and data won't provide the full<br/>picture. At worst, it may be a red herring or provide a false narrative.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">這並不意味著在協作中沒有情感的位置。在設計中，讓您感覺如何是很重要<br/>的。我們為人們思考並為他們創建解決方案，有情感並在決策中使用情感的<br/>人。在對話中留下的情感可能會縮短潛在的想法或解決方案。充其量，僅就事<br/>實和數據進行務實的討論將無法提供全面的信息。在最壞的情況下，它可能是<br/>掩人耳目或提供虛假的敘述。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">At Savvy, we empower our team to be "fearless" about receiving feedback. This<br/>means letting go of any anxieties about being judged for what we create. It also<br/>means understanding that we are stronger together and stand a greater chance of<br/>creating something great. In being fearless, we better trust and empower each other<br/>to give honest and thoughtful feedback.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">在與<span> </span></span><span class="fontstyle0">Savvy<span> </span></span><span class="fontstyle1">的合作中，我們使我們的團隊對收到反饋感到</span><span class="fontstyle0">“</span><span class="fontstyle1">無所畏懼</span><span class="fontstyle0">”</span><span class="fontstyle1">。這意味<br/>著放開對我們所創造的東西進行判斷不會感到任何焦慮。這也意味著我們在一<br/>起將會更加強大，更有機會創造偉大的事物。在無所畏懼的情況下，我們會更<br/>好地相互信任和相互賦予能力，以提供誠實和周到的反饋。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Our team also believes in being fearless about providing feedback. This means</span><br/><span>understanding the problem that needs solving as well as the customer's brand and</span><br/><span>goals. It also means asking lots of questions either to uncover relevant thoughts or to</span><br/><span>help guide decisions.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">我們的團隊還信奉無所畏懼地提供反饋。這意味著能夠了解需要解決的問題以<br/>及客戶的品牌和目標。同時也意味著可以問很多問題，以發現相關的思想或幫<br/>助指導決策。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Try presenting feedback in an exploratory and guiding manner, with the intent of<br/>building up and improving the work rather than tearing it down.</span></p>
<p><br/><span class="fontstyle1">嘗試以探索性和指導性的方式提出反饋意見，目的是建立和改進工作，而不是<br/>拆散工作。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Your feedback should be constructive. Instead of saying you don't like something,</span><br/><span>frame your feedback to point back to the problem you're trying to help solve.</span><br/><span>Provide actionable steps on improving the work or at the very least the reasoning</span><br/><span>behind your thinking. And don't forget to express what you like and why.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">您的反饋意見應具有建設性。與其說您不喜歡某些東西，不如說出您的反饋意<br/>見以指出您要幫助解決的問題。提供可行的步驟來改進工作，或者至少提供您<br/>思考背後的理由。並且不要忘了表達您喜歡什麼以及為什麼。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">COLLABORATION IS MORE THAN NEW IDEAS</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">合作不僅僅是新的想法</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">It's one thing to be open and accepting of collaborative feedback, another to parse<br/>those thoughts and use them as catalysts to spark your own. This is a more advanced<br/>skill that develops over time. One way to practice this is to become a better listener.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">開放並接受協作反饋是一回事，解析這些想法並將其用來催生您自己的想法是<br/>另一回事。隨著時間的推移，這是一項更高級的技能。實踐方法將使你成為更<br/>好去聽取意見的人。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Often, during a conversation with others, we think more about what we are going to<br/>say next rather than what others are saying. This impacts the feedback process,<br/>especially in design, because we often know what we want to say before hearing<br/>another opinion or solution.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">通常，在與他人交談時，我們會更多地考慮接下來要說的內容，而不是別人在<br/>說什麼。這會影響反饋過程，尤其是在設計過程中，因為在聽到其他意見或解<br/>決方案之前，我們通常會知道我們要說的話。</span></p>
<p><span><span class="fontstyle1"><br/></span><span class="fontstyle0">When you choose to listen first and react second, it allows you to fully understand<br/>the feedback someone else is presenting and sets you up to go deeper — what is the<br/>perspective they're using and the place they're coming from? Chances are this is a<br/>perspective you didn't consider during the creation process. By listening to and<br/>understanding the context and reasoning behind the feedback you're receiving,<br/>you're opening yourself to more ways of looking at, thinking of, and experiencing<br/>your design. You can then test these new perspectives against the challenges, goals,<br/>and use cases you're designing for to see if they better suit the user.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">當您選擇先聆聽然後再做出反應時，它可以讓您完全理解其他人的反饋，並讓<br/>您更深入地了解自己<span> </span></span><span class="fontstyle0">—<span> </span></span><span class="fontstyle1">他們使用的觀點是什麼以及來自何處？很有可能這是您<br/>在創建過程中未曾考慮過的觀點。通過聽取並理解收到反饋時背後的上下文和<br/>推理，您可以以更多的方式來審視，思考和體驗設計。然後，您可以針對要設</span><br/><span class="fontstyle1">計的挑戰，目標和用例子來測試這些新觀點，以查看它們是否更適合用戶。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">It's easier to be more receptive of feedback when all collaborators practice active<br/>listening. Ultimately, the skill of giving great feedback comes from learning how to<br/>receive it. As we make an effort to be better listeners, we also find ourselves<br/>becoming more humble and, in our opinion, better designers.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">當所有協作者都在積極聆聽時，更容易接受反饋。最終，提供良好反饋的技能<br/>來自於學習如何獲得反饋。當我們努力成為更好的聽眾時，我們也發現自己變<br/>得更加謙虛，並認為我們是更好的設計師。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Finding and Using the Right Design Collaboration Tools</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">尋找和使用正確的設計協作工具</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">The right tools go a long way in reinforcing your team's design collaboration mindset.<br/>In this section, you'll learn what to look for in collaboration tools. We also<br/>recommend tools based on our own experiences.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">正確的工具在增強團隊的設計協作思維方面大有幫助。在本節中，您將學習在<br/>協作工具中尋找什麼。我們還根據自己的經驗推薦工具。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">SELECTING THE RIGHT TOOLS</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">選擇合適的工具</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Effective collaboration tools remove all barriers for collaborators to quickly and</span><br/><span>easily access and interact with the work. This keeps the focus on giving feedback.</span><br/><span>They also allow others to collaborate on a design without destroying the original.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">有效的協作工具消除了協作者想要快速輕鬆地訪問工作並與之交互時的所有障<br/>礙。這將重點放在提供反饋上。它們還允許其他人在不破壞原始設計的情況下<br/>進行協作。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">In the past, we used relied on tools that provided basic versioning control instead of<br/>true collaborative features. For example, a designer would save a Sketch file and<br/>upload it to Dropbox. Another team member would then download it, work on it,<br/>and re-upload it. There was no easy way to make changes while the file was in<br/>another's hands. We tried something similar with Github, a tool that proved great for<br/>managing codebases, but not so much with iterative design work. Needless to say,<br/>these version control processes made our collaboration more time consuming,<br/>confusing, and very un-collaborative.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">過去，我們依賴於提供基本版本控製而不是真正的協作功能的工具。例如，設<br/>計人員將保存一個<span> </span></span><span class="fontstyle0">Sketch<span> </span></span><span class="fontstyle1">文件並將其上傳到<span> </span></span><span class="fontstyle0">Dropbox</span><span class="fontstyle1">。然後，另一個團隊成員<br/>下載它，進行處理，然後重新上傳。當文件在另一個人手中時，沒有辦法用簡</span><br/><span class="fontstyle1">單的方法來進行更改。我們使用<span> </span></span><span class="fontstyle0">Github<span> </span></span><span class="fontstyle1">嘗試了類似的方法，該工具被證明非常<br/>適合管理代碼庫，但對於反覆設計的工作卻沒有太多幫助。不用說，這些版本<br/>控製過程使我們的協作更加耗時，混亂並且非常不協作。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Now we choose from a variety of more advanced tools depending on the type of<br/>collaboration we want to achieve.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">現在，我們根據要實現的協作類型從各種更高級的工具中進行選擇。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">FIGMA<br/>This is a collaboration-first, shared workspace tool. Figma works well for having<br/>multiple people in same area of the design file. You can watch teammates design or<br/>work together on the same design in real time.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">這是一個以協作為優先的共享工作區工具。<span> </span></span><span class="fontstyle0">Figma<span> </span></span><span class="fontstyle1">非常適合在設計文件的同一<br/>區域中包含多個人。您可以時時觀看隊友的設計或在同一個設計上一起工作。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Benefits:</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">好處：</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Figma reduces the ability for someone to work in a silo.</span></span></p>
<p><span class="fontstyle0"><br/>Figma<span> </span></span><span class="fontstyle1">降低了某人在統合工作的時間。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">There's no need to add unnecessary polish or create static deliverables to enable<br/>collaboration. So you don't need to change your workflow to show off a design.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">無需添加不必要的修飾或創建可交付結果的靜態即可實現協作。因此，您無需<br/>更改工作流程即可展示設計。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>It's easy to see and interact with the work in its native environment and apply</span><br/><span>tweaks at will.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">可以輕鬆地在其本環境中查看並與之交互，並隨意進行調整。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">When to use: Flow docs, high-fidelity wireframes, spur-of-the-moment collaboration,<br/>and walking customers through a series of screens to explain and get feedback on<br/>design direction.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">使用時：流程文檔，高保真線框，即時協作，以及引導客戶瀏覽一系列屏幕，<br/>以解釋並獲得有關設計方向的反饋。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">MARVEL</span><br/><span class="fontstyle0">While Figma tends to feel more free-form and flexible, Marvel allows for a more<br/>standardized form of collaboration. It also makes it easy on our customers to<br/>collaborate with us.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">雖然<span> </span></span><span class="fontstyle0">Figma<span> </span></span><span class="fontstyle1">傾向於自由和靈活，但<span> </span></span><span class="fontstyle0">Marvel<span> </span></span><span class="fontstyle1">允許採用更標準化的協作形式。這也<br/>使我們的客戶可以輕鬆地與我們合作。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Benefits:</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">好處：</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Marvel is a cleaner, more formalized and focused space, great for collaborating with<br/>non-design team members.</span></p>
<p><span class="fontstyle0"><br/>Marvel<span> </span></span><span class="fontstyle1">是一個更簡潔、規範和專注的空間，非常適合與非設計團隊成員進行協<br/>作。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">It removes all need for the customer to pay for an account or have a deep<br/>understanding of the tool to see the work.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">它消除了客戶為帳戶付款或對工具進行深入了解的所有需求。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Customers can download screens and see them in action on a device environment<br/>via the Marvel app.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">客戶可以下載<span> </span></span><span class="fontstyle0">app</span><span class="fontstyle1">，並通過<span> </span></span><span class="fontstyle0">Marvel<span> </span></span><span class="fontstyle1">應用程序在設備環境中查看它們的運行情<br/>況。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">When to use: Presenting more finalized design work with customers and developers.<br/>(Learn about how Marvel compares with other prototyping tools.)</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">使用時：與客戶和開發人員一起呈現更多的最終設計工作。 （了解<span> </span></span><span class="fontstyle0">Marvel<span> </span></span><span class="fontstyle1">如何<br/>與其他原型工具進行比較。）</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">OTHER COLLABORATION TOOLS</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">其他合作工具</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Zeplin is a useful hand-off tool that allows developers to dive into the nitty gritty<br/>specs of design work. (We talk more in-depth about Zeplin here.)</span></p>
<p><span class="fontstyle0"><br/>Zeplin<span> </span></span><span class="fontstyle1">是一個有用的傳遞工具，使開發人員可以深入研究設計工作的細節。<br/>（我們在這裡更深入地討論<span> </span></span><span class="fontstyle0">Zeplin</span><span class="fontstyle1">。）</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Quip is a great platform for brainstorming and product/process documentation. We<br/>use it to record and organize all of the context and knowledge that team members</span><br/><span class="fontstyle0"><span>need to know when working on a project. It's also useful for brainstorming new ideas</span><br/><span>that aren't visual-focused.</span></span></p>
<p><span class="fontstyle0"><br/>Quip<span> </span></span><span class="fontstyle1">是集思廣益在產品</span><span class="fontstyle0">/</span><span class="fontstyle1">流程文件的絕佳平台。我們使用它來記錄和組織團隊成<br/>員在項目上需要了解的所有環境和知識。對於集思廣益新思路而不是視覺關注<br/>的新想法也很有用。</span></p>
<p><span class="fontstyle1"><br/></span><span><span class="fontstyle0">Please note that there are many other tools out there that add similar benefits to<br/>collaboration as the ones listed above. This list represents the tools that have<br/>worked well for us in our day-to-day collabora</span><span class="fontstyle0">tion and is not indicative of all the<br/>options that might work well for your team.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">請注意，還有許多其他工具可以為協作增加與上面類似的好處。此列表代表了<br/>在我們日常合作中對我們有效的工具，但並不表示所有可能對您的團隊有效的<br/>選項。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Savvy's Design Collaboration Process in Practice</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">精明的設計合作過程在實踐中</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Now let's take the best practices and tools outlined above and show how they fit</span><br/><span>together in a real-life situation. We'll use the live drawing experience in the Press</span><br/><span>Play app to demonstrate the importance of design collaboration. This experience</span><br/><span>involved significant collaboration from a number of team members across</span><br/><span>disciplines, including a visual designer, UX designer, developer, product manager,</span><br/><span>and of course, the customer.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">現在，讓我們採用上面概述的最佳實踐和工具，並展示它們如何在現實生活中<br/>融合在一起。我們將使用<span> </span></span><span class="fontstyle0">Press Play<span> </span></span><span class="fontstyle1">應用程序中的實際繪圖經驗來演示設計協作<br/>的重要性。這種經驗涉及多個學科領域的團隊成員之間的重大協作，其中包括<br/>視覺設計師，<span> </span></span><span class="fontstyle0">UX<span> </span></span><span class="fontstyle1">設計人員，開發人員，產品經理，當然還有客戶。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">THE CONTEXT AND CHALLENGE</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">語境與挑戰</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Press Play is a sweepstakes app that holds daily, weekly, and monthly drawings.</span><br/><span>Users earn tickets by watching ads and enter drawings by selecting five emojis.</span><br/><span>Winners are then rewarded based on how their choices match up with the drawing's</span><br/><span>randomly-selected emojis. This particular task had us creating a fun and exciting live</span><br/><span>experience for users awaiting the results of the live drawing.</span></span></p>
<p><span class="fontstyle0"><br/>Press Play<span> </span></span><span class="fontstyle1">是一個抽獎活動應用程序，可保存每日，每周和每月的圖紙。用戶通<br/>過觀看廣告賺取門票，並通過五個表情符號的選擇來輸入圖紙。然後，根據獲<br/>獎者的選擇與繪畫中隨機選擇的表情符號匹配的方式來獎勵獲獎者。這項特殊<br/>任務使我們為等待現場繪畫結果的用戶創造了一種有趣而激動人心的現場體<br/>驗。</span></p>
<p><br/><span class="fontstyle0">It was important for us to create a game-like animation for this experience. We<br/>especially wanted to evoke a sense of playfulness and anticipation on the screen<br/>where users go to see how their chosen emojis match up with those from the<br/>sweepstakes drawing.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">對於我們來說，為這種體驗創建類似遊戲的動畫非常重要。我們特別想在屏幕<br/>上喚起用戶的嬉戲感和期待感，讓用戶看到他們選擇的表情符號與抽獎活動圖<br/>上的表情符號相匹配。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>That said, we needed to be mindful of the level of complexity an animation requires</span><br/><span>and its impact on the overall product's timeline and cost. Our goal was to push the</span><br/><span>level of fidelity within a reasonable time without significantly impacting the project's</span><br/><span>budget.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">也就是說，我們需要注意動畫所需的複雜程度及其對整體產品時間表和成本的<br/>影響。我們的目標是在合理的時間內提高真實度，而又不顯著影響項目預算。</span></p>
<p><span class="fontstyle0">THE COLLABORATIVE PROCESS</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">合作過程</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Stage 1: Wireframes and Brainstorming</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">階段<span> </span></span><span class="fontstyle0">1</span><span class="fontstyle1">：線框和自由討論</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>First, a Savvy UX designer created Press Play's overall UX and wireframes,</span><br/><span>determining what screens were needed and the timing for each one. She also put</span><br/><span>together a rough concept (shown right) for the live drawing animation, expressing</span><br/><span>initial ideas based on customer's needs and the project's established UX.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">首先，一位精明的<span> </span></span><span class="fontstyle0">UX<span> </span></span><span class="fontstyle1">設計師創建了<span> </span></span><span class="fontstyle0">Press Play<span> </span></span><span class="fontstyle1">的整體<span> </span></span><span class="fontstyle0">UX<span> </span></span><span class="fontstyle1">和線框，確定需要哪<br/>些屏幕以及每個屏幕的時間安排。她還為實時繪畫動畫整理了一個粗略的概念<br/>（如右方所示），根據客戶的需求和項目已建立的用戶體驗表達了初步的想<br/>法。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>She presented the wireframes and the rough animation to the product manager and</span><br/><span>visual designer. Then all three met with the customer so everyone would hear the</span><br/><span>feedback directly.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">她向產品經理和視覺設計師展示了線框和粗糙的動畫。然後這三個人都與客戶<br/>會面，因此每個人都可以直接聽到反饋。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Stage 2: Research and Context</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">第二階段：研究與背景</span></p>
<p><br/><span class="fontstyle0"><span>The Savvy visual designer tasked with creating the actual live drawing animation</span><br/><span>came in with fresh eyes and without much prior knowledge of the Press Play</span><br/><span>product. To get up to speed, he talked in depth with the UX designer and product</span><br/><span>manager. He also dedicated additional research time to understand the overall</span><br/><span>product goals, challenges, and to familiarize himself with the work to date. As</span><br/><span>mentioned earlier, he was part of the wireframe presentation and present for the</span><br/><span>customer's feedback.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">精明的視覺設計師負責創建實際的繪畫動畫，他們的眼界較廣，而且對<span> </span></span><span class="fontstyle0">Press<br/>Play<span> </span></span><span class="fontstyle1">產品沒有太多的了解。為了加快速度，他與<span> </span></span><span class="fontstyle0">UX<span> </span></span><span class="fontstyle1">設計師和產品經理進行了<br/>深入交流。他還花費額外的研究時間來了解總體產品目標，挑戰並熟悉迄今為<br/>止的工作。如前所述，他展示線框演示的一部分，並向客戶提出反饋。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>With that context, he conducted some additional research more directly related to</span><br/><span>the task at hand. In doing so, he made sure he understood the live drawing</span><br/><span>experience requirements, goals, and challenges. He looked at other apps with similar</span><br/><span>experiences and fidelity and referenced the rough animation to know what exactly</span><br/><span>the final animation needed to show (in this case, the winning emojis and the user's</span><br/><span>emoji selections). Before getting too tied to a solution, he met with a Savvy iOS</span><br/><span>developer to understand technical constraints and considerations.</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">在這種情況下，他進行了一些與手頭任務直接相關的其他研究。通過這樣做，<br/>他確保自己了解現場繪畫體驗的要求、目標和挑戰。他查看了具有類似體驗和<br/>真實度的其他應用，並參考了粗糙的動畫以了解最終動畫到底需要顯示什麼<br/>（在這種情況下，是獲勝的表情符號和用戶的表情符號選擇）。在過於依賴解<br/>決方案之前，他會見了一位精明的<span> </span></span><span class="fontstyle0">iOS<span> </span></span><span class="fontstyle1">開發人員，以了解技術限制和注意事<br/>項。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0"><span>Our visual designer and UX designer then brainstormed what was important for the</span><br/><span>visuals. They agreed that there needed to be a slow reveal to build up</span><br/><span>suspense/anticipation for the user</span></span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">然後，我們的視覺設計師和<span> </span></span><span class="fontstyle0">UX<span> </span></span><span class="fontstyle1">設計師集思廣益，視覺效果非常重要。他們一<br/>致認為，需要慢慢進行透露，以便為用戶建立懸念</span><span class="fontstyle0">/</span><span class="fontstyle1">期待</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Stage 3: Iteration and Feedback</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">階段<span> </span></span><span class="fontstyle0">3</span><span class="fontstyle1">： 意見統整和反饋</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">As our visual designer worked through a number of different directions he tapped<br/>the UX designer to chat through his progress and designs in Figma. By talking<br/>through the work they spurred more ideas and iterations while making sure they<br/>were staying true to customer expectations. With more solid options at hand, he<br/>met once again with the iOS developer to make sure everything was in line from a<br/>technical perspective.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">當我們的視覺設計師沿多個不同方向工作時，他邀請了<span> </span></span><span class="fontstyle0">UX<span> </span></span><span class="fontstyle1">設計師來聊聊他在</span><br/><span class="fontstyle0">Figma<span> </span></span><span class="fontstyle1">中的進度和設計。通過討論工作，他們激發了更多的想法和迭代，同時<br/>確保它們符合客戶的期望。有了更多可靠的選擇，他再次與<span> </span></span><span class="fontstyle0">iOS<span> </span></span><span class="fontstyle1">開發人員會<br/>面，以確保從技術角度來看一切都符合要求。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Stage 4: Customer Feedback and Development</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">階段<span> </span></span><span class="fontstyle0">4</span><span class="fontstyle1">：客戶的反饋和發展</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">When we landed on several, more finalized versions of the experience, the visual<br/>designer walked through them with the customer using Figma. The product manager<br/>and UX designer for Press Play provided feedback and guidance as well.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">當我們找到了幾種最終確定的體驗版本時，視覺設計師使用<span> </span></span><span class="fontstyle0">Figma<span> </span></span><span class="fontstyle1">與客戶一起<br/>瀏覽了它們。<span> </span></span><span class="fontstyle0">Press Play<span> </span></span><span class="fontstyle1">的產品經理和<span> </span></span><span class="fontstyle0">UX<span> </span></span><span class="fontstyle1">設計師也提供了反饋和指導。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Once they all learned what piqued the customer's interest, the visual designer set off<br/>to maximize the visuals and make them ready for development. He continued to<br/>work with the iOS developer to get the most out of the concept on a technical level.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">一旦他們都了解了會引起客戶興趣的東西，視覺設計師便開始著手讓視覺效果<br/>最大化，並為開發做好準備。他繼續與<span> </span></span><span class="fontstyle0">iOS<span> </span></span><span class="fontstyle1">開發人員合作，以在技術層面上充<br/>分利用該概念。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">THE END RESULT</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">最終結果</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Press Play's live drawing animation is an example of design collaboration at work; a<br/>team of cross-discipline experts working together to solve a design and development<br/>challenge with bigger implications. Without design collaboration, we wouldn't have<br/>discovered the ideal intersection of user experience, visual, and technical.</span></p>
<p><span class="fontstyle0"><br/>Press Play<span> </span></span><span class="fontstyle1">的實際繪圖動畫是工作中設計協作的一個示例。一隊跨學科專家團<br/>隊，共同解決具有更大影響的設計和開發挑戰。沒有設計協作，我們將找不到<br/>用戶體驗，視覺和技術之間的理想交匯處。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">When the customer saw the animation alive in his app he called it "groundbreaking."</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">當客戶在他的應用程序中看到動畫是生動時，他稱其為</span><span class="fontstyle0">“</span><span class="fontstyle1">開創性的</span><span class="fontstyle0">”</span><span class="fontstyle1">。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">What’s more, the research, collaboration, and creation of this Press Play experience<br/>helped us discover a gap in the product’s user journey. Originally, the live drawing’s<br/>intent was to be a fun way to show the results to users. As we moved through the<br/>design process, we realized that if a user doesn’t watch the live drawing, and they<br/>lose, they don’t get to experience an end to their user journey for that drawing.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">此外，對這種<span> </span></span><span class="fontstyle0">Press Play<span> </span></span><span class="fontstyle1">體驗的研究、協作和創造，幫助我們發現了產品用戶旅<br/>程中的空白。最初，實際繪圖的目的是將結果顯示給用戶的一種有趣的方式。</span><br/><span class="fontstyle1">在設計過程中，我們意識到，如果用戶不因為觀看實際圖形而迷失了方向，那<br/>麼他們就不會體驗到該圖形的用戶旅程。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">From that discovery, we decided to improve the app in a couple of other places as<br/>well. We added a results/live drawing element to the Winner’s Circle and a win-lose<br/>history section to the User Details side of the app. In the end, design collaboration<br/>empowered us to realize this unfulfilled need in the user experience.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">基於這一發現，我們決定在其他兩個地方也改進該應用程序。我們在</span><span class="fontstyle0">“</span><span class="fontstyle1">獲勝者圈<br/>子</span><span class="fontstyle0">”</span><span class="fontstyle1">中添加了一個結果</span><span class="fontstyle0">/</span><span class="fontstyle1">實際繪圖元素，並在應用程序的</span><span class="fontstyle0">“</span><span class="fontstyle1">用戶詳細信息</span><span class="fontstyle0">”</span><span class="fontstyle1">端添加<br/>了</span><span class="fontstyle0">“</span><span class="fontstyle1">輸贏歷史記錄</span><span class="fontstyle0">”</span><span class="fontstyle1">部分。最後，設計協作使我們能夠實現用戶體驗中這未滿足<br/>的需求。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">Concluding Note</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">結論說明</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">It takes design collaboration to tackle the complex, crucial problems that come along<br/>with building great products and experiences. By leveraging the specialized expertise<br/>of multiple team members across disciplines, design collaboration makes sure teams<br/>meet challenges from all perspectives and come to better solutions. With the right<br/>mindset, tools, and process, design collaboration empowers teams to go deeper with<br/>creative thinking and iteration.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">它需要設計協調來處理構建出色的產品和體驗所伴隨的複雜並關鍵的問題。通<br/>過利用跨學科的多個團隊成員的專業知識，設計協作可確保團隊從各個角度應<br/>對挑戰並尋求更好的解決方案。通過正確的思維方式、工具和流程，設計協調<br/>能使團隊能夠通過創造性思維和更深入迭代。</span></p>
<p><span class="fontstyle1"><br/></span><span class="fontstyle0">We hope this guide gives you a good foundation from which you can build your own<br/>effective design collaboration process. You can learn more about design and product<br/>strategy on the Savvy blog, and feel free to contact us for help on the Savvy Apps<br/>website.</span></p>
<p><span class="fontstyle0"><br/></span><span class="fontstyle1">我們希望本指南為您提供一個良好的基礎，您可以以此為基礎建立自己的有效<br/>設計協作流程。您可以在<span> </span></span><span class="fontstyle0">Savvy<span> </span></span><span class="fontstyle1">博客上了解有關設計和產品策略的更多信息，<br/>也可以隨時在<span> </span></span><span class="fontstyle0">Savvy Apps<span> </span></span><span class="fontstyle1">網站上與我們聯繫以獲取幫助。</span></p>
<h3>MechanicalDesignProcess</h3>
<h3>Keyboard control car</h3>